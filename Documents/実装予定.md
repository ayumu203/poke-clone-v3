# フロントエンド実装予定

## 目次

1. [概要](#概要)
2. [バックエンドAPI仕様](#バックエンドapi仕様)
3. [認証フロー](#認証フロー)
4. [フロントエンド実装手順](#フロントエンド実装手順)
5. [環境構築](#環境構築)
6. [デプロイ手順](#デプロイ手順)

---

## 概要

本ドキュメントは、ポケモンクローンゲームのフロントエンド実装の完全なガイドです。バックエンドAPIとSignalRを活用し、リアルタイム対戦機能を実現します。

### システム構成

```
┌─────────────────┐         ┌──────────────────┐         ┌─────────────┐
│ React/Next.js   │  HTTP   │  ASP.NET Core    │  Redis  │   Redis     │
│  フロント       ├────────►│  WebAPI          ├────────►│   Cache     │
│                 │◄────────┤  + SignalR Hub   │         └─────────────┘
└─────────────────┘ SignalR └──────────────────┘
                              ↓
                         ┌──────────────────┐
                         │  SQL Server DB   │
                         └──────────────────┘
```

---

## バックエンドAPI仕様

### 1. 認証API

#### POST `/api/Auth/login/mock`

**用途**: 開発用モック認証（本番では無効化）

**リクエスト**:
```json
{
  "username": "testplayer1",
  "password": "testpassword"
}
```

**レスポンス**:
```json
{
  "message": "Logged in",
  "username": "testplayer1",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Auth/login/mock \
  -H "Content-Type: application/json" \
  -d '{"username": "testplayer1", "password": "testpassword"}'
```

**使用方法**:
1. JWTトークンを取得
2. トークンをローカルストレージまたはCookieに保存（レスポンスにはCookieも自動設定されます）
3. 以降のAPIリクエストで`Authorization: Bearer {token}`ヘッダーを付与

#### POST `/api/Auth/logout`

**用途**: ログアウト（Cookieからトークンを削除）

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Auth/logout \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### GET `/api/Auth/status`

**用途**: 現在の認証状態を確認

**レスポンス**:
```json
{
  "isAuthenticated": true,
  "userId": "user-uuid-1234",
  "name": "testplayer1",
  "message": "Authenticated"
}
```

**curlテスト例**:
```bash
# 認証なし
curl -X GET http://localhost:5278/api/Auth/status

# 認証あり
curl -X GET http://localhost:5278/api/Auth/status \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### 2. プレイヤーAPI

#### GET `/api/Player/me`

**用途**: 認証済みユーザーのプレイヤー情報を取得

**レスポンス例**:
```json
{
  "playerId": "user-uuid-1234",
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Player/me \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### POST `/api/Player/me`

**用途**: プレイヤー情報の作成または更新

**リクエスト**:
```json
{
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Player/me \
  -H "Authorization: Bearer {YOUR_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"name": "サトシ", "iconUrl": "https://example.com/icon.png"}'
```

---

### 3. パーティAPI

#### GET `/api/Party`

**用途**: プレイヤーのパーティ一覧を取得

**レスポンス例**:
```json
[
  {
    "pokemonId": "poke001",
    "pokemonSpeciesId": 25,
    "level": 25,
    "exp": 0,
    "moves": [
      {
        "moveId": 1,
        "name": "でんきショック",
        "type": "Electric",
        "damageClass": "Special",
        "power": 40,
        "accuracy": 100,
        "pp": 30
      }
    ]
  }
]
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Party \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### DELETE `/api/Party/{pokemonId}`

**用途**: ポケモンを逃がす（パーティから削除）

**curlテスト例**:
```bash
curl -X DELETE http://localhost:5278/api/Party/{pokemonId} \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### 4. スターターAPI

#### GET `/api/Starter/options`

**用途**: スターターポケモンの選択肢を取得

**レスポンス例**:
```json
[
  {
    "pokemonSpeciesId": 390,
    "name": "ヒコザル",
    "frontImage": "/images/390_front.png",
    "backImage": "/images/390_back.png",
    "type1": "Fire",
    "type2": null,
    "baseHp": 44,
    "baseAttack": 58,
    "baseDefence": 44,
    "baseSpecialAttack": 58,
    "baseSpecialDefence": 44,
    "baseSpeed": 61,
    "moveList": []
  }
]
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Starter/options \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### POST `/api/Starter/select`

**用途**: スターターポケモンを選択

**リクエスト**:
```json
{
  "pokemonSpeciesId": 390
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Starter/select \
  -H "Authorization: Bearer {YOUR_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"pokemonSpeciesId": 390}'
```

---

### 5. バトルAPI

#### POST `/api/Battle/cpu`

**用途**: CPUバトルの作成

**レスポンス例**:
```json
{
  "battleId": "battle-uuid-1234",
  "player1": {
    "playerId": "user-uuid-1234",
    "player": {
      "playerId": "user-uuid-1234",
      "name": "サトシ",
      "iconUrl": "https://example.com/icon.png"
    },
    "activePokemonIndex": 0,
    "party": [
      {
        "pokemonId": "poke001",
        "pokemonSpeciesId": 25,
        "currentHp": 95,
        "maxHp": 95,
        "ailment": "None",
        "rank": {
          "attack": 0,
          "defence": 0,
          "specialAttack": 0,
          "specialDefence": 0,
          "speed": 0,
          "accuracy": 0,
          "evasion": 0
        }
      }
    ],
    "action": null
  },
  "player2": {
    "playerId": "cpu",
    "player": {
      "playerId": "cpu",
      "name": "CPU",
      "iconUrl": null
    },
    "activePokemonIndex": 0,
    "party": [
      {
        "pokemonId": "cpu-poke001",
        "pokemonSpeciesId": 19,
        "currentHp": 60,
        "maxHp": 60,
        "ailment": "None",
        "rank": {
          "attack": 0,
          "defence": 0,
          "specialAttack": 0,
          "specialDefence": 0,
          "speed": 0,
          "accuracy": 0,
          "evasion": 0
        }
      }
    ],
    "action": null
  },
  "turn": 0,
  "createdAt": "2025-12-05T01:00:00Z",
  "expireAt": "2025-12-05T02:00:00Z"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Battle/cpu \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### GET `/api/Battle/{battleId}`

**用途**: 現在のバトル状態を取得

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Battle/{battleId} \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### 6. SignalR Hub (BattleHub)

#### `JoinBattle(string battleId)`

**目的**: バトルルームへの接続

**フロントエンド実装**:
```typescript
// SignalR接続確立後に呼び出す
await connection.invoke("JoinBattle", battleId);
```

#### `SubmitAction(string battleId, PlayerAction action)`

**目的**: プレイヤーのアクションを送信

**PlayerAction構造**:
```typescript
interface PlayerAction {
  playerId: string;
  actionType: ActionType;  // 0: Attack, 1: Switch, 2: Catch
  value: number;           // moveIdまたはswitchPokemonIndex
}

enum ActionType {
  Attack = 0,
  Switch = 1,
  Catch = 2
}
```

**フロントエンド実装**:
```typescript
// 攻撃アクション
const attackAction = {
  playerId: "player1",
  actionType: 0, // Attack
  value: 1  // moveId
};

await connection.invoke("SubmitAction", battleId, attackAction);

// 交代アクション
const switchAction = {
  playerId: "player1",
  actionType: 1, // Switch
  value: 2  // pokemonIndex
};

await connection.invoke("SubmitAction", battleId, switchAction);
```

#### `ReceiveTurnResult` (クライアント受信)

**目的**: ターン処理結果の受信

**ProcessResult構造**:
```typescript
interface ProcessResult {
  actionResults: ActionResult[];
  isBattleEnd: boolean;
  winnerId: string;
  endResult?: EndResult;
}

interface ActionResult {
  actionPokemonId: string;
  actionType: number;
  moveResult?: MoveResult;
  switchResult?: SwitchResult;
  catchResult?: CatchResult;
  escapeResult?: EscapeResult;
}

interface MoveResult {
  moveId: number;
  targetId: string;
  isSuccess: boolean;
  failureReason: string;
  damage: number;
  hitContext?: {
    isCritical: boolean;
    typeEffectiveness: number;
  };
  sourceRankChange?: Rank;
  targetRankChange?: Rank;
  ailment?: string;
  sourceStatChanges?: StatChange[];
  targetStatChanges?: StatChange[];
  healing?: number;
  drain?: number;
}

interface EndResult {
  reason: string;  // "AllFainted", "Caught", "Escaped"
  winnerId?: string;
  evolutionInfo?: EvolutionInfo[];
}
```

**フロントエンド実装**:
```typescript
connection.on("ReceiveTurnResult", (result: ProcessResult) => {
  // ターン結果を処理
  result.actionResults.forEach(action => {
    if (action.moveResult) {
      // ダメージアニメーション表示
      displayDamage(action.moveResult.damage);
      
      // HP更新
      updatePokemonHp(action.moveResult.targetId, action.moveResult.damage);
      
      // エフェクト表示
      if (action.moveResult.hitContext?.isCritical) {
        showCriticalEffect();
      }
    }
  });
  
  // バトル終了判定
  if (result.isBattleEnd) {
    showBattleResult(result.endResult);
  }
});
```

---

## 機密情報の管理

### 質問: appsettings.jsonの接続情報は実装予定.mdを実施することで隠匿できますか？

**回答**: はい、実装予定.mdに記載された手順を実施することで、appsettings.jsonおよびappsettings.Development.jsonに含まれる機密情報を適切に隠匿できます。

### 現在の問題点

現在、以下のファイルに機密情報が平文で記載されています：

- **`appsettings.json`**:
  - データベース接続文字列（SQLサーバーのパスワード）
  - Redis接続文字列
  
- **`appsettings.Development.json`**:
  - JWT秘密鍵（`Jwt:Key`）

これらのファイルはGitリポジトリにコミットされるため、セキュリティリスクがあります。

### 対策方法

#### 開発環境での対策: User Secrets

開発環境では、.NET Core の **User Secrets** 機能を使用して機密情報を管理します。

**手順**:

```bash
# プロジェクトディレクトリに移動
cd Server/src/Server.WebAPI

# User Secrets初期化（既に初期化済みの場合はスキップ）
dotnet user-secrets init

# JWT秘密鍵を設定（32文字以上推奨）
dotnet user-secrets set "Jwt:Key" "{YOUR_JWT_SECRET_KEY_MINIMUM_32_CHARACTERS}"

# データベース接続文字列を設定（開発環境用）
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "Server=localhost,1433;Database=PokeCloneDb;User Id=sa;Password={YOUR_DB_PASSWORD};TrustServerCertificate=True;"

# Redis接続文字列を設定
dotnet user-secrets set "ConnectionStrings:Redis" "localhost:6379"

# 設定確認
dotnet user-secrets list
```

**User Secretsの保存場所**:
- Windows: `%APPDATA%\Microsoft\UserSecrets\{user-secrets-id}\secrets.json`
- Linux/Mac: `~/.microsoft/usersecrets/{user-secrets-id}/secrets.json`

**メリット**:
- Gitリポジトリにコミットされない
- 開発者ごとに異なる設定を使用可能
- appsettings.Development.jsonから機密情報を削除できる

**appsettings.Development.json の修正後**:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Authentication": {
    "Schemes": {
      "Bearer": {
        "ValidAudiences": [
          "http://localhost:4287",
          "https://localhost:44314",
          "http://localhost:5278",
          "https://localhost:7269"
        ],
        "ValidIssuer": "dotnet-user-jwts"
      }
    }
  }
  // Jwt:Key はUser Secretsから読み込まれる
}
```

#### 本番環境での対策: Azure Key Vault

本番環境では、**Azure Key Vault** を使用してすべての機密情報を管理します。

**手順**:

1. **Key Vault の作成**:

```bash
az keyvault create \
  --name {YOUR_KEYVAULT_NAME} \
  --resource-group poke-clone-rg \
  --location japaneast
```

2. **シークレットの登録**:

```bash
# JWTシークレットキー
az keyvault secret set \
  --vault-name {YOUR_KEYVAULT_NAME} \
  --name Jwt--Key \
  --value "{YOUR_PRODUCTION_JWT_SECRET_KEY}"

# データベース接続文字列
az keyvault secret set \
  --vault-name {YOUR_KEYVAULT_NAME} \
  --name ConnectionStrings--DefaultConnection \
  --value "Server=tcp:{YOUR_SQL_SERVER}.database.windows.net,1433;Initial Catalog=pokedb;User ID={YOUR_SQL_USER};Password={YOUR_SQL_PASSWORD};Encrypt=True;"

# Redis接続文字列
az keyvault secret set \
  --vault-name {YOUR_KEYVAULT_NAME} \
  --name ConnectionStrings--Redis \
  --value "{YOUR_REDIS_HOST}.redis.cache.windows.net:6380,password={YOUR_REDIS_KEY},ssl=True,abortConnect=False"
```

3. **マネージドIDの設定**:

```bash
# App ServiceのマネージドIDを有効化
az webapp identity assign \
  --name {YOUR_WEBAPP_NAME} \
  --resource-group poke-clone-rg

# Key Vaultアクセスポリシーを設定
az keyvault set-policy \
  --name {YOUR_KEYVAULT_NAME} \
  --object-id {MANAGED_IDENTITY_PRINCIPAL_ID} \
  --secret-permissions get list
```

4. **App Service環境変数の設定**:

```bash
az webapp config appsettings set \
  --name {YOUR_WEBAPP_NAME} \
  --resource-group poke-clone-rg \
  --settings \
    ASPNETCORE_ENVIRONMENT=Production \
    KeyVault__VaultUri=https://{YOUR_KEYVAULT_NAME}.vault.azure.net/
```

**メリット**:
- 中央集権的なシークレット管理
- アクセス監査ログの記録
- 自動的なシークレットローテーション対応
- appsettings.jsonから完全に機密情報を分離

### 実施後の確認

以下のチェックリストで確認してください：

**開発環境**:
- [ ] `appsettings.Development.json`から`Jwt:Key`を削除
- [ ] `dotnet user-secrets list`で設定を確認
- [ ] アプリケーションが正常に起動し、JWTトークンが発行されることを確認

**本番環境**:
- [ ] Azure Key Vaultにすべてのシークレットが登録されている
- [ ] App ServiceのマネージドIDがKey Vaultへアクセス可能
- [ ] `appsettings.json`に機密情報が含まれていない
- [ ] デプロイ後、アプリケーションが正常に動作することを確認

---

## 認証フロー

### 開発環境での認証

開発環境では、モック認証を使用して迅速にテストできます。

#### モック認証フロー

```typescript
// pages/login.tsx
async function handleMockLogin() {
  const response = await fetch('http://localhost:5278/api/Auth/login/mock', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'devuser', password: 'devpass' })
  });
  
  const data = await response.json();
  localStorage.setItem('jwt_token', data.token);
  window.location.href = '/';
}
```

> [!WARNING]
> **モック認証は開発環境専用**
> 本番環境では、Google OAuth、Microsoft OAuth、またはEmail OTPを使用してください。

---

### 本番環境での認証: Azure AD B2C (External ID)

本番環境では、Azure AD B2C (External Entra ID) を使用して、外部IDプロバイダー（Google、Microsoft）およびEmail OTPによる認証を実装します。

#### Azure AD B2Cの設定

##### 1. Azure AD B2Cテナントの作成

```bash
# Azure AD B2Cテナントの作成
az ad b2c tenant create \
  --resource-name {YOUR_B2C_TENANT_NAME} \
  --resource-group poke-clone-rg \
  --sku Standard
```

作成後、以下の情報を記録してください：
- **テナント名**: `{YOUR_B2C_TENANT_NAME}.onmicrosoft.com`
- **テナントID**: `{YOUR_TENANT_ID}`

##### 2. アプリケーション登録

Azure Portal (https://portal.azure.com) でAzure AD B2Cテナントに切り替えて、以下を実施：

1. **App registrations** > **New registration**
2. アプリケーション情報を入力：
   - **Name**: `poke-clone-spa`
   - **Supported account types**: Accounts in any identity provider or organizational directory
   - **Redirect URI**: 
     - Type: `Single-page application (SPA)`
     - URI: `https://{YOUR_FRONTEND_DOMAIN}/auth/callback`
     - 開発環境用: `http://localhost:3000/auth/callback`
3. 登録後、以下を記録：
   - **Application (client) ID**: `{YOUR_CLIENT_ID}`

##### 3. IDプロバイダーの設定

**Google OAuth 2.0の設定**:

1. [Google Cloud Console](https://console.cloud.google.com/)でOAuth 2.0クライアントIDを作成：
   - **承認済みのリダイレクトURI**: `https://{YOUR_B2C_TENANT_NAME}.b2clogin.com/{YOUR_B2C_TENANT_NAME}.onmicrosoft.com/oauth2/authresp`
2. 取得した情報を記録：
   - **Client ID**: `{GOOGLE_CLIENT_ID}`
   - **Client Secret**: `{GOOGLE_CLIENT_SECRET}`

3. Azure AD B2Cで **Identity providers** > **New OpenID Connect provider**:
   - **Name**: `Google`
   - **Metadata URL**: `https://accounts.google.com/.well-known/openid-configuration`
   - **Client ID**: `{GOOGLE_CLIENT_ID}`
   - **Client Secret**: `{GOOGLE_CLIENT_SECRET}`
   - **Scope**: `openid profile email`
   - **Response type**: `code`

**Microsoft アカウントの設定**:

1. Azure AD B2Cで **Identity providers** > **Microsoft Account**を選択
2. 自動的に構成されるため、有効化のみで使用可能

**Email OTP (ワンタイムパスワード)の設定**:

1. Azure AD B2Cで **Identity providers** > **Email One-time Passcode**を選択
2. 有効化して保存

##### 4. ユーザーフローの作成

1. **User flows** > **New user flow**
2. **Sign up and sign in**を選択
3. ユーザーフロー情報を入力：
   - **Name**: `signupsignin1`（最終的なフローURL: `B2C_1_signupsignin1`）
   - **Identity providers**: Google, Microsoft Account, Email OTP を選択
   - **User attributes and claims**: 以下を選択
     - Collect: `Display Name`, `Email Address`
     - Return: `Display Name`, `Email Addresses`, `User's Object ID`
4. **Create**をクリック

##### 5. API権限の設定（バックエンド用）

バックエンドAPIを保護するため、API登録を作成：

1. **App registrations** > **New registration**
2. アプリケーション情報を入力：
   - **Name**: `poke-clone-api`
   - **Supported account types**: Accounts in any identity provider
3. **Expose an API** > **Add a scope**:
   - **Scope name**: `access_as_user`
   - **Admin consent display name**: `Access API as user`
   - **Admin consent description**: `Allows the app to access the API as the user`
4. 記録：
   - **Application ID URI**: `https://{YOUR_B2C_TENANT_NAME}.onmicrosoft.com/api`
   - **Scope**: `https://{YOUR_B2C_TENANT_NAME}.onmicrosoft.com/api/access_as_user`

#### フロントエンド実装

##### MSAL.jsを使用した認証実装

**インストール**:

```bash
pnpm install @azure/msal-browser @azure/msal-react
```

**設定ファイル**: `lib/auth/msalConfig.ts`

```typescript
import { Configuration, PublicClientApplication } from '@azure/msal-browser';

export const msalConfig: Configuration = {
  auth: {
    clientId: '{YOUR_CLIENT_ID}',
    authority: 'https://{YOUR_B2C_TENANT_NAME}.b2clogin.com/{YOUR_B2C_TENANT_NAME}.onmicrosoft.com/B2C_1_signupsignin1',
    knownAuthorities: ['{YOUR_B2C_TENANT_NAME}.b2clogin.com'],
    redirectUri: process.env.NEXT_PUBLIC_REDIRECT_URI || 'http://localhost:3000/auth/callback',
    postLogoutRedirectUri: '/',
  },
  cache: {
    cacheLocation: 'localStorage',
    storeAuthStateInCookie: false,
  },
};

export const loginRequest = {
  scopes: ['openid', 'profile', 'email', 'https://{YOUR_B2C_TENANT_NAME}.onmicrosoft.com/api/access_as_user'],
};

export const msalInstance = new PublicClientApplication(msalConfig);
```

**Reactプロバイダー設定**: `app/layout.tsx`

```typescript
'use client';

import { MsalProvider } from '@azure/msal-react';
import { msalInstance } from '@/lib/auth/msalConfig';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ja">
      <body>
        <MsalProvider instance={msalInstance}>
          {children}
        </MsalProvider>
      </body>
    </html>
  );
}
```

**ログインコンポーネント**: `components/Auth/LoginButton.tsx`

```typescript
'use client';

import { useMsal } from '@azure/msal-react';
import { loginRequest } from '@/lib/auth/msalConfig';

export default function LoginButton() {
  const { instance } = useMsal();

  const handleLogin = async () => {
    try {
      await instance.loginPopup(loginRequest);
      // ログイン成功後、トークンを取得してバックエンドに送信
      const accounts = instance.getAllAccounts();
      if (accounts.length > 0) {
        const response = await instance.acquireTokenSilent({
          ...loginRequest,
          account: accounts[0],
        });
        
        // バックエンドに送信してセッション作成
        await fetch('/api/Auth/azure-login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ accessToken: response.accessToken }),
        });
      }
    } catch (error) {
      console.error('Login failed:', error);
    }
  };

  return (
    <button onClick={handleLogin} className="btn-primary">
      Sign in with Azure AD B2C
    </button>
  );
}
```

**認証フック**: `hooks/useAuth.ts`

```typescript
import { useMsal } from '@azure/msal-react';
import { loginRequest } from '@/lib/auth/msalConfig';

export function useAuth() {
  const { instance, accounts } = useMsal();

  const getAccessToken = async (): Promise<string | null> => {
    if (accounts.length === 0) return null;

    try {
      const response = await instance.acquireTokenSilent({
        ...loginRequest,
        account: accounts[0],
      });
      return response.accessToken;
    } catch (error) {
      console.error('Failed to acquire token silently:', error);
      // トークン取得失敗時は再ログインを促す
      await instance.loginPopup(loginRequest);
      return null;
    }
  };

  const logout = () => {
    instance.logoutPopup();
  };

  return {
    isAuthenticated: accounts.length > 0,
    user: accounts[0],
    getAccessToken,
    logout,
  };
}
```

#### バックエンド実装

##### NuGetパッケージのインストール

```bash
cd Server/src/Server.WebAPI
dotnet add package Microsoft.Identity.Web
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

**appsettings.json**: Azure AD B2C設定を追加

```json
{
  "AzureAdB2C": {
    "Instance": "https://{YOUR_B2C_TENANT_NAME}.b2clogin.com",
    "ClientId": "{YOUR_CLIENT_ID}",
    "Domain": "{YOUR_B2C_TENANT_NAME}.onmicrosoft.com",
    "SignUpSignInPolicyId": "B2C_1_signupsignin1",
    "TenantId": "{YOUR_TENANT_ID}"
  }
}
```

**Program.cs**: 認証設定を追加

```csharp
using Microsoft.Identity.Web;
using Microsoft.AspNetCore.Authentication.JwtBearer;

var builder = WebApplication.CreateBuilder(args);

// Azure AD B2C認証を追加
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection("AzureAdB2C"));

// 既存のサービス登録...

var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();

// 既存のミドルウェア...

app.Run();
```

**AuthController.cs**: Azure AD B2Cトークン検証エンドポイントを追加

```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IConfiguration _configuration;

    public AuthController(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    [HttpPost("azure-login")]
    public async Task<IActionResult> AzureLogin([FromBody] AzureLoginRequest request)
    {
        // Azure AD B2Cからのアクセストークンを検証（自動的に[Authorize]属性で検証される）
        // ここではユーザーIDを取得してセッション作成
        var userId = User.FindFirst("sub")?.Value ?? User.FindFirst("oid")?.Value;
        var email = User.FindFirst("emails")?.Value;
        var name = User.FindFirst("name")?.Value;

        // プレイヤーレコードを取得または作成
        // （既存のロジックを使用）

        return Ok(new { userId, email, name });
    }
}

public record AzureLoginRequest(string AccessToken);
```

#### 環境変数の設定

**フロントエンド** (`.env.production`):

```bash
NEXT_PUBLIC_B2C_CLIENT_ID={YOUR_CLIENT_ID}
NEXT_PUBLIC_B2C_TENANT_NAME={YOUR_B2C_TENANT_NAME}
NEXT_PUBLIC_B2C_POLICY=B2C_1_signupsignin1
NEXT_PUBLIC_REDIRECT_URI=https://{YOUR_FRONTEND_DOMAIN}/auth/callback
NEXT_PUBLIC_API_URL=https://{YOUR_BACKEND_DOMAIN}
```

**バックエンド**: Azure Key Vaultに登録

```bash
az keyvault secret set \
  --vault-name {YOUR_KEYVAULT_NAME} \
  --name AzureAdB2C--ClientId \
  --value "{YOUR_CLIENT_ID}"

az keyvault secret set \
  --vault-name {YOUR_KEYVAULT_NAME} \
  --name AzureAdB2C--TenantId \
  --value "{YOUR_TENANT_ID}"
```


---

## フロントエンド実装手順

### Step 1: プロジェクトセットアップ

#### 必要なライブラリ

```bash
# Next.js（推奨）
pnpm dlx create-next-app@latest poke-clone-frontend --typescript

# SignalR クライアント
pnpm install @microsoft/signalr

# 状態管理（Zustand推奨）
pnpm install zustand

# APIクライアント
pnpm install axios

# スタイリング
pnpm install tailwindcss @tailwindcss/forms

# zod
pnpm add zod

# zod関連
pnpm install -D openapi-zod-client typescript
pnpm install @zodios/core

# Storybook のセットアップ
pnpm dlx storybook@latest init
```

#### プロジェクト構造

```
Client/
├── src/
│   ├── components/
│   │   ├── Battle/
│   │   │   ├── BattleField.tsx
│   │   │   ├── BattleField.stories.tsx
│   │   │   ├── PokemonDisplay.tsx
│   │   │   ├── PokemonDisplay.stories.tsx
│   │   │   ├── HPBar.tsx
│   │   │   ├── HPBar.stories.tsx
│   │   │   ├── MoveSelector.tsx
│   │   │   ├── MoveSelector.stories.tsx
│   │   │   └── BattleLog.tsx
│   │   └── Auth/
│   │       ├── Login.tsx
│   │       └── Login.stories.tsx
│   ├── hooks/
│   │   ├── useBattle.ts
│   │   ├── useSignalR.ts
│   │   └── useAuth.ts
│   ├── services/
│   │   ├── api.ts
│   │   └── signalr.ts
│   ├── stores/
│   │   ├── battleStore.ts
│   │   └── authStore.ts
│   ├── types/
│   │   ├── battle.ts
│   │   ├── pokemon.ts
│   │   └── action.ts
│   └── utils/
│       ├── typeEffectiveness.ts
│       └── damageCalculator.ts
│
├── .storybook/
│   ├── main.js
│   └── preview.js
│
├── .env.development
├── .env.production
└── package.json
```

---

### Step 2: 型定義

**`types/battle.ts`**:

```typescript
export interface BattleState {
  battleId: string;
  player1: PlayerState;
  player2: PlayerState;
  turn: number;
  createdAt: string;
  expireAt?: string;
}

export interface PlayerState {
  playerId: string;
  player: Player;
  activePokemonIndex: number;
  party: PokemonState[];
  action?: PlayerAction;
}

export interface PokemonState {
  pokemonId: string;
  pokemonSpeciesId: number;
  currentHp: number;
  maxHp: number;
  ailment: Ailment;
  rank: Rank;
  isFainted?: boolean;
}

export interface Player {
  playerId: string;
  name: string;
  iconUrl?: string;
}

export interface Rank {
  attack: number;
  defence: number;
  specialAttack: number;
  specialDefence: number;
  speed: number;
  accuracy: number;
  evasion: number;
}

export type Ailment = 
  | 'None' 
  | 'Paralysis' 
  | 'Sleep' 
  | 'Freeze' 
  | 'Burn' 
  | 'Poison' 
  | 'DeadlyPoisoned';

export type PokemonStat = 
  | 'attack' 
  | 'defense' 
  | 'special-attack' 
  | 'special-defense' 
  | 'speed' 
  | 'accuracy' 
  | 'evasion';

export interface StatChange {
  stat: PokemonStat;
  change: number;  // -6 ~ +6 の範囲
}

export interface PlayerAction {
  playerId: string;
  actionType: ActionType;
  value: number;  // moveId or switchPokemonIndex
}

export enum ActionType {
  Attack = 0,
  Switch = 1,
  Catch = 2
}

export interface ProcessResult {
  actionResults: ActionResult[];
  isBattleEnd: boolean;
  winnerId: string;
  endResult?: EndResult;
}

export interface ActionResult {
  actionPokemonId: string;
  actionType: ActionType;
  moveResult?: MoveResult;
  switchResult?: SwitchResult;
  catchResult?: CatchResult;
  escapeResult?: EscapeResult;
}

export interface MoveResult {
  moveId: number;
  targetId: string;
  isSuccess: boolean;
  failureReason: string;
  damage: number;
  hitContext?: {
    isCritical: boolean;
    typeEffectiveness: number;
  };
  sourceRankChange?: Rank;
  targetRankChange?: Rank;
  ailment?: string;
  sourceStatChanges?: StatChange[];
  targetStatChanges?: StatChange[];
  healing?: number;
  drain?: number;
}

export interface SwitchResult {
  currentPokemonId: string;
  nextPokemonId: string;
}

export interface CatchResult {
  isSuccess: boolean;
  caughtPokemonId: string;
}

export interface EscapeResult {
  isSuccess: boolean;
}

export interface EndResult {
  reason: string;
  winnerId?: string;
  evolutionInfo?: EvolutionInfo[];
}

export interface EvolutionInfo {
  pokemonId: string;
  fromSpeciesId: number;
  toSpeciesId: number;
  fromSpeciesName: string;
  toSpeciesName: string;
}
```

---

### Step 3: SignalR接続管理

**`services/signalr.ts`**:

```typescript
import * as signalR from '@microsoft/signalr';

class SignalRService {
  private connection: signalR.HubConnection | null = null;
  
  async connect(token: string): Promise<signalR.HubConnection> {
    if (this.connection) {
      return this.connection;
    }
    
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5278';
    
    this.connection = new signalR.HubConnectionBuilder()
      .withUrl(`${apiUrl}/hubs/battle`, {
        accessTokenFactory: () => token,
        transport: signalR.HttpTransportType.WebSockets
      })
      .withAutomaticReconnect()
      .configureLogging(signalR.LogLevel.Information)
      .build();
    
    await this.connection.start();
    console.log('SignalR Connected');
    
    return this.connection;
  }
  
  async disconnect(): Promise<void> {
    if (this.connection) {
      await this.connection.stop();
      this.connection = null;
      console.log('SignalR Disconnected');
    }
  }
  
  getConnection(): signalR.HubConnection | null {
    return this.connection;
  }
}

export const signalRService = new SignalRService();
```

---

### Step 4: カスタムフック

**`hooks/useSignalR.ts`**:

```typescript
import { useEffect, useState } from 'react';
import { signalRService } from '@/services/signalr';
import { ProcessResult, PlayerAction, BattleState } from '@/types/battle';
import * as signalR from '@microsoft/signalr';

export const useSignalR = (
  battleId: string,
  token: string,
  onTurnResult: (result: ProcessResult) => void,
  onBattleStarted?: (state: BattleState) => void
) => {
  const [connection, setConnection] = useState<signalR.HubConnection | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const setupConnection = async () => {
      try {
        const conn = await signalRService.connect(token);
        
        // ターン結果受信ハンドラ
        conn.on('ReceiveTurnResult', (result: ProcessResult) => {
          console.log('Turn result received:', result);
          onTurnResult(result);
        });
        
        // バトル開始受信ハンドラ
        conn.on('BattleStarted', (state: BattleState) => {
          console.log('Battle started:', state);
          if (onBattleStarted) {
            onBattleStarted(state);
          }
        });
        
        // バトル終了受信ハンドラ
        conn.on('BattleEnded', (endResult: any) => {
          console.log('Battle ended:', endResult);
        });
        
        // エラー受信ハンドラ
        conn.on('Error', (errorMessage: string) => {
          console.error('SignalR Error:', errorMessage);
          setError(errorMessage);
        });
        
        // バトルルームに参加
        await conn.invoke('JoinBattle', battleId);
        
        setConnection(conn);
        setIsConnected(true);
      } catch (err) {
        console.error('SignalR connection error:', err);
        setError(err instanceof Error ? err.message : 'Unknown error');
      }
    };
    
    setupConnection();
    
    return () => {
      signalRService.disconnect();
    };
  }, [battleId, token]);
  
  const submitAction = async (action: PlayerAction) => {
    if (!connection) {
      throw new Error('SignalR not connected');
    }
    
    try {
      await connection.invoke('SubmitAction', battleId, action);
    } catch (err) {
      console.error('Failed to submit action:', err);
      throw err;
    }
  };
  
  return { connection, isConnected, error, submitAction };
};
```

---

### Step 5: バトル状態管理

**`stores/battleStore.ts`** (Zustand使用):

```typescript
import { create } from 'zustand';
import { BattleState, ProcessResult, PokemonState } from '@/types/battle';

interface BattleStore {
  battleState: BattleState | null;
  turnResult: ProcessResult | null;
  battleLog: string[];
  isWaitingForOpponent: boolean;
  
  setBattleState: (state: BattleState) => void;
  setTurnResult: (result: ProcessResult) => void;
  addLog: (message: string) => void;
  clearLog: () => void;
  updatePokemonHp: (pokemonId: string, damage: number) => void;
  setWaitingForOpponent: (waiting: boolean) => void;
  resetBattle: () => void;
}

export const useBattleStore = create<BattleStore>((set) => ({
  battleState: null,
  turnResult: null,
  battleLog: [],
  isWaitingForOpponent: false,
  
  setBattleState: (state) => set({ battleState: state }),
  
  setTurnResult: (result) => set({ turnResult: result }),
  
  addLog: (message) => set((state) => ({
    battleLog: [...state.battleLog, message]
  })),
  
  clearLog: () => set({ battleLog: [] }),
  
  updatePokemonHp: (pokemonId, damage) => set((state) => {
    if (!state.battleState) return state;
    
    const updateParty = (party: PokemonState[]) =>
      party.map(p => 
        p.pokemonId === pokemonId
          ? { ...p, currentHp: Math.max(0, p.currentHp - damage) }
          : p
      );
    
    return {
      battleState: {
        ...state.battleState,
        player1: {
          ...state.battleState.player1,
          party: updateParty(state.battleState.player1.party)
        },
        player2: {
          ...state.battleState.player2,
          party: updateParty(state.battleState.player2.party)
        }
      }
    };
  }),
  
  setWaitingForOpponent: (waiting) => set({ isWaitingForOpponent: waiting }),
  
  resetBattle: () => set({
    battleState: null,
    turnResult: null,
    battleLog: [],
    isWaitingForOpponent: false
  })
}));
```

---

### Step 6: カスタムフックによるAPI取得方法

フロントエンドでは、API呼び出しを効率的に管理するため、カスタムフックを使用します。これにより、認証トークンの自動付与、エラーハンドリング、ローディング状態の管理が一元化され、コードの再利用性が向上します。

#### 汎用APIフック: `useApi`

**`hooks/useApi.ts`**:

```typescript
import { useState, useCallback } from 'react';
import { useAuth } from './useAuth';

interface UseApiOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: any;
  headers?: Record<string, string>;
}

export function useApi<T = any>() {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const { getAccessToken } = useAuth();

  const request = useCallback(async (
    url: string,
    options: UseApiOptions = {}
  ): Promise<T | null> => {
    setLoading(true);
    setError(null);

    try {
      const token = await getAccessToken();
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5278';
      
      const response = await fetch(`${apiUrl}${url}`, {
        method: options.method || 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token ? `Bearer ${token}` : '',
          ...options.headers,
        },
        body: options.body ? JSON.stringify(options.body) : undefined,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      setData(result);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      console.error('API request failed:', errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, [getAccessToken]);

  return { data, error, loading, request };
}
```

#### リソース別カスタムフック

各リソースごとに専用のカスタムフックを作成し、API呼び出しを簡潔にします。

##### `usePlayer`: プレイヤー情報管理

**`hooks/usePlayer.ts`**:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useApi } from './useApi';

interface Player {
  playerId: string;
  name: string;
  iconUrl?: string;
}

export function usePlayer() {
  const { request } = useApi<Player>();
  const queryClient = useQueryClient();

  // プレイヤー情報の取得
  const { data: player, isLoading, error } = useQuery({
    queryKey: ['player', 'me'],
    queryFn: () => request('/api/Player/me'),
    staleTime: 5 * 60 * 1000, // 5分間キャッシュ
  });

  // プレイヤー情報の更新
  const updatePlayer = useMutation({
    mutationFn: (data: { name: string; iconUrl?: string }) =>
      request('/api/Player/me', { method: 'POST', body: data }),
    onSuccess: () => {
      // キャッシュを無効化して再取得
      queryClient.invalidateQueries({ queryKey: ['player', 'me'] });
    },
  });

  return {
    player,
    isLoading,
    error,
    updatePlayer: updatePlayer.mutate,
    isUpdating: updatePlayer.isPending,
  };
}
```

##### `useParty`: パーティ情報管理

**`hooks/useParty.ts`**:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useApi } from './useApi';

interface Pokemon {
  pokemonId: string;
  pokemonSpeciesId: number;
  level: number;
  exp: number;
  moves: Move[];
}

export function useParty() {
  const { request } = useApi<Pokemon[]>();
  const queryClient = useQueryClient();

  // パーティ一覧の取得
  const { data: party, isLoading, error } = useQuery({
    queryKey: ['party'],
    queryFn: () => request('/api/Party'),
    staleTime: 2 * 60 * 1000, // 2分間キャッシュ
  });

  // ポケモンを逃がす
  const releasePokemon = useMutation({
    mutationFn: (pokemonId: string) =>
      request(`/api/Party/${pokemonId}`, { method: 'DELETE' }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['party'] });
    },
  });

  return {
    party,
    isLoading,
    error,
    releasePokemon: releasePokemon.mutate,
    isReleasing: releasePokemon.isPending,
  };
}
```

##### `useStarter`: スターターポケモン選択

**`hooks/useStarter.ts`**:

```typescript
import { useQuery, useMutation } from '@tanstack/react-query';
import { useApi } from './useApi';

interface StarterOption {
  pokemonSpeciesId: number;
  name: string;
  frontImage: string;
  backImage: string;
  type1: string;
  type2?: string;
  baseHp: number;
  baseAttack: number;
  baseDefence: number;
  baseSpecialAttack: number;
  baseSpecialDefence: number;
  baseSpeed: number;
}

export function useStarter() {
  const { request } = useApi();

  // スターター選択肢の取得
  const { data: options, isLoading } = useQuery<StarterOption[]>({
    queryKey: ['starter', 'options'],
    queryFn: () => request('/api/Starter/options'),
  });

  // スターターを選択
  const selectStarter = useMutation({
    mutationFn: (pokemonSpeciesId: number) =>
      request('/api/Starter/select', {
        method: 'POST',
        body: { pokemonSpeciesId },
      }),
  });

  return {
    options,
    isLoading,
    selectStarter: selectStarter.mutate,
    isSelecting: selectStarter.isPending,
  };
}
```

##### `useBattle`: バトル管理

**`hooks/useBattle.ts`**:

```typescript
import { useQuery, useMutation } from '@tanstack/react-query';
import { useApi } from './useApi';
import { BattleState } from '@/types/battle';

export function useBattle(battleId?: string) {
  const { request } = useApi();

  // バトル状態の取得
  const { data: battleState, isLoading } = useQuery<BattleState>({
    queryKey: ['battle', battleId],
    queryFn: () => request(`/api/Battle/${battleId}`),
    enabled: !!battleId, // battleIdが存在する場合のみクエリを実行
    refetchInterval: false, // SignalRで更新されるため自動リフレッシュ不要
  });

  // CPUバトルの作成
  const createCpuBattle = useMutation({
    mutationFn: () => request('/api/Battle/cpu', { method: 'POST' }),
  });

  return {
    battleState,
    isLoading,
    createCpuBattle: createCpuBattle.mutate,
    isCreating: createCpuBattle.isPending,
  };
}
```

#### React Query プロバイダー設定

**インストール**:

```bash
pnpm install @tanstack/react-query
```

**`app/layout.tsx`**: QueryClientProviderを追加

```typescript
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // デフォルトで1分間キャッシュ
        retry: 1, // 失敗時1回のみリトライ
      },
    },
  }));

  return (
    <html lang="ja">
      <body>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </body>
    </html>
  );
}
```

#### 使用例

**コンポーネントでの使用**:

```typescript
'use client';

import { usePlayer } from '@/hooks/usePlayer';
import { useParty } from '@/hooks/useParty';

export default function PlayerProfile() {
  const { player, isLoading: playerLoading, updatePlayer } = usePlayer();
  const { party, isLoading: partyLoading } = useParty();

  if (playerLoading || partyLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{player?.name}</h1>
      <button onClick={() => updatePlayer({ name: '新しい名前' })}>
        名前を変更
      </button>
      
      <h2>手持ちポケモン</h2>
      <ul>
        {party?.map((pokemon) => (
          <li key={pokemon.pokemonId}>
            Lv.{pokemon.level} - {pokemon.pokemonSpeciesId}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### キャッシング戦略

React Queryを使用することで、以下のメリットが得られます：

1. **自動キャッシング**: 一度取得したデータは設定した期間キャッシュされる
2. **バックグラウンド更新**: 古いデータを表示しながら、バックグラウンドで最新データを取得
3. **重複リクエストの防止**: 同じクエリキーのリクエストは自動的にバッチング
4. **楽観的更新**: サーバーの応答を待たずにUIを更新可能
5. **エラーリトライ**: ネットワークエラー時の自動リトライ

**キャッシュ時間の設定方針**:
- プレイヤー情報: 5分（頻繁に変更されない）
- パーティ情報: 2分（バトル後に更新される可能性）
- バトル情報: キャッシュなし（SignalRでリアルタイム更新）
- スターター選択肢: 無期限（静的データ）

---

### Step 7: フロントエンドレンダリング方法（DS風2画面レイアウト）

ニンテンドーDS風の2画面レイアウトを実装します。上画面にポケモンの画像やバトル画面を表示し、下画面にボタンや情報パネルを配置、ヘッダーにはナビゲーションリンクとBGMトグルスイッチを配置します。

#### レイアウト構成

```
┌─────────────────────────────────────────┐
│  Header (ナビゲーション + BGMトグル)     │
├─────────────────────────────────────────┤
│                                         │
│         上画面 (Top Screen)              │
│    ポケモン画像・バトル画面など           │
│      (Documents/Images の画像)          │
│                                         │
├─────────────────────────────────────────┤
│                                         │
│        下画面 (Bottom Screen)            │
│   ボタン・情報パネル・コマンドメニュー     │
│                                         │
└─────────────────────────────────────────┘
```

#### 基本レイアウトコンポーネント

**`components/templates/DSLayout.tsx`**:

```typescript
'use client';

import { ReactNode } from 'react';
import Header from '@/components/organisms/Header';
import styles from './DSLayout.module.css';

interface DSLayoutProps {
  topScreen: ReactNode;
  bottomScreen: ReactNode;
}

export default function DSLayout({ topScreen, bottomScreen }: DSLayoutProps) {
  return (
    <div className={styles.container}>
      <Header />
      
      <main className={styles.main}>
        {/* 上画面 */}
        <section className={styles.topScreen}>
          <div className={styles.topScreenContent}>
            {topScreen}
          </div>
        </section>

        {/* 下画面 */}
        <section className={styles.bottomScreen}>
          <div className={styles.bottomScreenContent}>
            {bottomScreen}
          </div>
        </section>
      </main>
    </div>
  );
}
```

**`components/templates/DSLayout.module.css`**:

```css
.container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  background: linear-gradient(to bottom, #1a1a2e, #16213e);
}

.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding: 0;
  overflow: hidden;
}

/* 上画面: 60%の高さ */
.topScreen {
  flex: 6;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: 4px solid #2a2a3e;
  border-radius: 12px 12px 0 0;
  margin: 8px 8px 0 8px;
  overflow: hidden;
  position: relative;
  box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
}

.topScreenContent {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 16px;
}

/* 下画面: 40%の高さ */
.bottomScreen {
  flex: 4;
  background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
  border: 4px solid #2a2a3e;
  border-radius: 0 0 12px 12px;
  margin: 0 8px 8px 8px;
  overflow: hidden;
  position: relative;
  box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
}

.bottomScreenContent {
  width: 100%;
  height: 100%;
  padding: 16px;
  overflow-y: auto;
}

/* レスポンシブ対応 */
@media (min-width: 768px) {
  .main {
    flex-direction: row;
    gap: 8px;
  }

  .topScreen,
  .bottomScreen {
    flex: 1;
    margin: 8px;
    border-radius: 12px;
  }
}
```

#### ヘッダーコンポーネント

**`components/organisms/Header.tsx`**:

```typescript
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { useAudio } from '@/hooks/useAudio';
import styles from './Header.module.css';

export default function Header() {
  const { isPlaying, toggle } = useAudio('/audio/bgm.mp3');

  return (
    <header className={styles.header}>
      <nav className={styles.nav}>
        <Link href="/" className={styles.navLink}>
          ホーム
        </Link>
        <Link href="/party" className={styles.navLink}>
          手持ち
        </Link>
        <Link href="/battle" className={styles.navLink}>
          バトル
        </Link>
        <Link href="/profile" className={styles.navLink}>
          プロフィール
        </Link>
      </nav>

      {/* BGMトグルスイッチ */}
      <div className={styles.audioControls}>
        <label className={styles.switch}>
          <input
            type="checkbox"
            checked={isPlaying}
            onChange={toggle}
            aria-label="BGM ON/OFF"
          />
          <span className={styles.slider}></span>
        </label>
        <span className={styles.audioLabel}>
          BGM {isPlaying ? 'ON' : 'OFF'}
        </span>
      </div>
    </header>
  );
}
```

**`components/organisms/Header.module.css`**:

```css
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 24px;
  background: linear-gradient(90deg, #2d3748 0%, #1a202c 100%);
  border-bottom: 2px solid #4a5568;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.nav {
  display: flex;
  gap: 24px;
}

.navLink {
  color: #e2e8f0;
  text-decoration: none;
  font-weight: 600;
  font-size: 16px;
  transition: color 0.2s ease;
  position: relative;
}

.navLink:hover {
  color: #667eea;
}

.navLink::after {
  content: '';
  position: absolute;
  bottom: -4px;
  left: 0;
  width: 0;
  height: 2px;
  background: #667eea;
  transition: width 0.3s ease;
}

.navLink:hover::after {
  width: 100%;
}

.audioControls {
  display: flex;
  align-items: center;
  gap: 12px;
}

.audioLabel {
  color: #e2e8f0;
  font-size: 14px;
  font-weight: 500;
}

/* トグルスイッチ */
.switch {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 24px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #4a5568;
  transition: 0.3s;
  border-radius: 24px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.3s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #667eea;
}

input:checked + .slider:before {
  transform: translateX(24px);
}
```

#### BGM管理カスタムフック

**`hooks/useAudio.ts`**:

```typescript
import { useState, useEffect, useRef } from 'react';

export function useAudio(src: string) {
  const [isPlaying, setIsPlaying] = useState(false);
  const audioRef = useRef<HTMLAudioElement | null>(null);

  useEffect(() => {
    // Audio要素を作成
    audioRef.current = new Audio(src);
    audioRef.current.loop = true;
    audioRef.current.volume = 0.3; // 音量を30%に設定

    return () => {
      // クリーンアップ
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
    };
  }, [src]);

  const toggle = () => {
    if (!audioRef.current) return;

    if (isPlaying) {
      audioRef.current.pause();
    } else {
      audioRef.current.play().catch((error) => {
        console.error('Failed to play audio:', error);
      });
    }
    setIsPlaying(!isPlaying);
  };

  const setVolume = (volume: number) => {
    if (audioRef.current) {
      audioRef.current.volume = Math.max(0, Math.min(1, volume));
    }
  };

  return { isPlaying, toggle, setVolume };
}
```

#### 使用例: バトル画面

**`app/battle/page.tsx`**:

```typescript
'use client';

import DSLayout from '@/components/templates/DSLayout';
import BattleTopScreen from '@/components/organisms/BattleTopScreen';
import BattleBottomScreen from '@/components/organisms/BattleBottomScreen';

export default function BattlePage() {
  return (
    <DSLayout
      topScreen={<BattleTopScreen />}
      bottomScreen={<BattleBottomScreen />}
    />
  );
}
```

**`components/organisms/BattleTopScreen.tsx`**:

```typescript
'use client';

import Image from 'next/image';
import { useBattle } from '@/hooks/useBattle';
import styles from './BattleTopScreen.module.css';

export default function BattleTopScreen() {
  const { battleState } = useBattle();

  if (!battleState) {
    return <div className={styles.loading}>Loading...</div>;
  }

  const playerPokemon = battleState.player1.party[battleState.player1.activePokemonIndex];
  const enemyPokemon = battleState.player2.party[battleState.player2.activePokemonIndex];

  return (
    <div className={styles.container}>
      {/* 相手ポケモン */}
      <div className={styles.enemyPokemon}>
        <Image
          src={`/images/art_${enemyPokemon.pokemonSpeciesId.toString().padStart(3, '0')}.png`}
          alt={`Pokemon ${enemyPokemon.pokemonSpeciesId}`}
          width={200}
          height={200}
          className={styles.pokemonImage}
        />
        <div className={styles.hpBar}>
          <div 
            className={styles.hpFill} 
            style={{ width: `${(enemyPokemon.currentHp / enemyPokemon.maxHp) * 100}%` }}
          />
        </div>
        <div className={styles.pokemonInfo}>
          HP: {enemyPokemon.currentHp} / {enemyPokemon.maxHp}
        </div>
      </div>

      {/* 自分のポケモン */}
      <div className={styles.playerPokemon}>
        <Image
          src={`/images/art_${playerPokemon.pokemonSpeciesId.toString().padStart(3, '0')}.png`}
          alt={`Pokemon ${playerPokemon.pokemonSpeciesId}`}
          width={200}
          height={200}
          className={styles.pokemonImage}
        />
        <div className={styles.hpBar}>
          <div 
            className={styles.hpFill} 
            style={{ width: `${(playerPokemon.currentHp / playerPokemon.maxHp) * 100}%` }}
          />
        </div>
        <div className={styles.pokemonInfo}>
          HP: {playerPokemon.currentHp} / {playerPokemon.maxHp}
        </div>
      </div>
    </div>
  );
}
```

**`components/organisms/BattleTopScreen.module.css`**:

```css
.container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 24px;
  background: url('/images/battle-background.png') center/cover no-repeat;
  position: relative;
}

.enemyPokemon {
  align-self: flex-end;
  text-align: right;
  animation: slideInRight 0.5s ease-out;
}

.playerPokemon {
  align-self: flex-start;
  text-align: left;
  animation: slideInLeft 0.5s ease-out;
}

.pokemonImage {
  filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));
  transition: transform 0.3s ease;
}

.pokemonImage:hover {
  transform: scale(1.05);
}

.hpBar {
  width: 200px;
  height: 12px;
  background: #2d3748;
  border-radius: 6px;
  overflow: hidden;
  margin-top: 8px;
  border: 2px solid #4a5568;
}

.hpFill {
  height: 100%;
  background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
  transition: width 0.5s ease;
  border-radius: 4px;
}

.pokemonInfo {
  color: #e2e8f0;
  font-weight: 600;
  margin-top: 4px;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

@keyframes slideInRight {
  from {
    transform: translateX(100px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideInLeft {
  from {
    transform: translateX(-100px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
```

**`components/organisms/BattleBottomScreen.tsx`**:

```typescript
'use client';

import { useBattle } from '@/hooks/useBattle';
import styles from './BattleBottomScreen.module.css';

export default function BattleBottomScreen() {
  const { battleState } = useBattle();

  const handleMoveClick = (moveIndex: number) => {
    // Move selection logic
    console.log('Selected move:', moveIndex);
  };

  return (
    <div className={styles.container}>
      <div className={styles.commandMenu}>
        <button className={styles.moveButton} onClick={() => handleMoveClick(0)}>
          技 1
        </button>
        <button className={styles.moveButton} onClick={() => handleMoveClick(1)}>
          技 2
        </button>
        <button className={styles.moveButton} onClick={() => handleMoveClick(2)}>
          技 3
        </button>
        <button className={styles.moveButton} onClick={() => handleMoveClick(3)}>
          技 4
        </button>
      </div>

      <div className={styles.infoPanel}>
        <p className={styles.infoText}>
          コマンドを選択してください
        </p>
      </div>
    </div>
  );
}
```

**`components/organisms/BattleBottomScreen.module.css`**:

```css
.container {
  display: flex;
  flex-direction: column;
  gap: 16px;
  height: 100%;
}

.commandMenu {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
  flex: 1;
}

.moveButton {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 16px;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
}

.moveButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
}

.moveButton:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.infoPanel {
  background: rgba(0, 0, 0, 0.4);
  border-radius: 8px;
  padding: 12px;
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.infoText {
  color: #e2e8f0;
  font-size: 16px;
  text-align: center;
  margin: 0;
}
```

#### デザイン参考資料

実装時は、以下のデザインファイルを参考にしてください：

- **対戦画面(コマンド選択)**: `/home/cs23017/poke-clone-v3/Design/対戦画面(コマンド選択).png`
- **メニュー画面**: `/home/cs23017/poke-clone-v3/Design/メニュー画面.png`
- **ポケモン詳細画面**: `/home/cs23017/poke-clone-v3/Design/ポケモン詳細画面.png`
- **手持ちポケモン画面**: `/home/cs23017/poke-clone-v3/Design/手持ちポケモン画面.png`

#### ポケモン画像の配置

ポケモンの画像は `/Documents/Images` にあります：
- ファイル形式: `art_001.png` - `art_200.png`
- 使用方法: Next.jsの`<Image>`コンポーネントで読み込む

```typescript
// 例: ポケモンSpeciesID 25 (ピカチュウ)の画像を表示
<Image
  src="/images/art_025.png"
  alt="Pikachu"
  width={200}
  height={200}
/>
```

---

## 環境構築

### 開発環境

#### 1. 環境変数設定

**`.env.development`**:
```bash
NEXT_PUBLIC_API_URL=http://localhost:5278
NEXT_PUBLIC_SIGNALR_URL=http://localhost:5278/hubs/battle
NEXT_PUBLIC_ENVIRONMENT=development
```

#### 2. Docker環境の起動

```bash
# プロジェクトルートで実行
cd Server
docker compose up -d

# いらんくね？
# データベース初期化
dotnet ef database update --project src/Server.Infrastructure --startup-project src/Server.WebAPI

# シードデータ投入
dotnet run --project scripts/Program.cs
```

#### 3. User Secretsの設定

> [!IMPORTANT]
> **機密情報の管理**
> 
> 開発環境では、JWT秘密鍵などの機密情報は`appsettings.Development.json`に含めず、User Secretsで管理します。

```bash
# プロジェクトディレクトリに移動
cd Server/src/Server.WebAPI

# User Secrets初期化（既に初期化済みの場合はスキップ）
dotnet user-secrets init

# JWT秘密鍵を設定（32文字以上推奨）
dotnet user-secrets set "Jwt:Key" "ThisIsASecretKeyForDevelopmentOnly_DoNotUseInProduction_32CharactersMinimum"

# 設定確認
dotnet user-secrets list
```

**設定される内容**:
- `Jwt:Key`: JWT秘密鍵（開発環境用）
- このキーは`%APPDATA%\Microsoft\UserSecrets\[user-secrets-id]\secrets.json`（Windows）または`~/.microsoft/usersecrets/[user-secrets-id]/secrets.json`（Linux/Mac）に安全に保存されます
- Gitにコミットされることはありません

#### 4. バックエンド起動

```bash
cd Server/src/Server.WebAPI
dotnet run
```

#### 5. フロントエンド起動

```bash
cd Client
npm install
npm run dev
```

#### 5. Storybook起動（オプション）

```bash
cd Client
npm run storybook
```

---

### 本番環境（Azureデプロイ）

#### 1. Azureリソース作成

```bash
# リソースグループ作成
az group create \
  --name poke-clone-rg \
  --location japaneast

# App Service Plan作成
az appservice plan create \
  --name poke-clone-plan \
  --resource-group poke-clone-rg \
  --sku B1 \
  --is-linux

# Web App作成
az webapp create \
  --name poke-clone-api \
  --resource-group poke-clone-rg \
  --plan poke-clone-plan \
  --runtime "DOTNETCORE:8.0"

# Azure SQL Database作成
az sql server create \
  --name poke-clone-db-server \
  --resource-group poke-clone-rg \
  --location japaneast \
  --admin-user sqladmin \
  --admin-password YourPassword123!

az sql db create \
  --name pokedb \
  --resource-group poke-clone-rg \
  --server poke-clone-db-server \
  --service-objective S0

# Azure Cache for Redis作成
az redis create \
  --name poke-clone-redis \
  --resource-group poke-clone-rg \
  --location japaneast \
  --sku Basic \
  --vm-size c0

# Azure SignalR Service作成
az signalr create \
  --name poke-clone-signalr \
  --resource-group poke-clone-rg \
  --location japaneast \
  --sku Standard_S1 \
  --service-mode Default

# Key Vault作成
az keyvault create \
  --name poke-clone-keyvault \
  --resource-group poke-clone-rg \
  --location japaneast
```

#### 2. シークレット登録

```bash
# JWTシークレットキー
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name Jwt--Key \
  --value "your-super-secure-jwt-secret-key-minimum-32-characters"

# データベース接続文字列
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name ConnectionStrings--DefaultConnection \
  --value "Server=tcp:poke-clone-db-server.database.windows.net,1433;Initial Catalog=pokedb;Persist Security Info=False;User ID=sqladmin;Password=YourPassword123!;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"

# Redis接続文字列
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name ConnectionStrings--Redis \
  --value "poke-clone-redis.redis.cache.windows.net:6380,password=xxxxxxxxx,ssl=True,abortConnect=False"

# Azure SignalR接続文字列
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name Azure--SignalR--ConnectionString \
  --value "Endpoint=https://poke-clone-signalr.service.signalr.net;AccessKey=xxxxxxxxx;Version=1.0;"
```

#### 3. App Serviceマネージドアイデンティティ設定

```bash
# マネージドアイデンティティを有効化
az webapp identity assign \
  --name poke-clone-api \
  --resource-group poke-clone-rg

# Key Vaultアクセスポリシーを設定
az keyvault set-policy \
  --name poke-clone-keyvault \
  --object-id {PRINCIPAL_ID} \
  --secret-permissions get list
```

#### 4. 環境変数設定

```bash
az webapp config appsettings set \
  --name poke-clone-api \
  --resource-group poke-clone-rg \
  --settings \
    ASPNETCORE_ENVIRONMENT=Production \
    KeyVault__VaultUri=https://poke-clone-keyvault.vault.azure.net/
```

---

## デプロイ手順

### GitHub Actionsでのデプロイ

**`.github/workflows/azure-deploy.yml`**:

```yaml
name: Deploy to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: poke-clone-api
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore Server/PokeClone.sln
    
    - name: Build
      run: dotnet build Server/PokeClone.sln --configuration Release --no-restore
    
    - name: Publish
      run: dotnet publish Server/src/Server.WebAPI/Server.WebAPI.csproj --configuration Release --no-build --output ./publish
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ./publish
```

### Vercelへのフロントエンドデプロイ

**`vercel.json`**:

```json
{
  "buildCommand": "npm run build",
  "outputDirectory": ".next",
  "framework": "nextjs",
  "env": {
    "NEXT_PUBLIC_API_URL": "https://poke-clone-api.azurewebsites.net",
    "NEXT_PUBLIC_SIGNALR_URL": "https://poke-clone-api.azurewebsites.net/hubs/battle",
    "NEXT_PUBLIC_ENVIRONMENT": "production"
  }
}
```

---

## セキュリティチェックリスト

### 開発環境

- [ ] User Secretsを使用してJWT秘密鍵を管理（`dotnet user-secrets set`）
- [ ] `appsettings.Development.json`に機密情報（JWT Key、パスワードなど）を含めない
- [ ] Gitに`.env`ファイルをコミットしない
- [ ] CORS設定をlocalhostに限定
- [ ] Docker Composeで使用するパスワードは開発用の簡易的なものを使用

### 本番環境

- [ ] Azure Key Vaultですべてのシークレットを管理
- [ ] マネージドIDを使用してKey Vaultにアクセス
- [ ] HTTPS必須を有効化
- [ ] JWT SecretKeyは32文字以上のランダム文字列
- [ ] CORS設定を本番ドメインのみに限定
- [ ] Redisにパスワードを設定
- [ ] SQL DatabaseでAzure AD認証を有効化
- [ ] App ServiceでHTTPS Only設定を有効化
- [ ] 定期的にシークレットをローテーション

---

## トラブルシューティング

### SignalR接続エラー

**症状**: `Failed to start the connection: Error: WebSocket failed to connect.`

**原因**:
- バックエンドが起動していない
- CORS設定が正しくない
- JWTトークンが無効

**解決方法**:
1. バックエンドが起動していることを確認
2. `appsettings.Development.json`のCORS設定を確認
3. ブラウザのコンソールでJWTトークンを確認

### 認証エラー

**症状**: `401 Unauthorized`

**原因**:
- JWTトークンが期限切れ
- トークンがリクエストヘッダーに含まれていない

**解決方法**:
1. ローカルストレージのトークンを確認
2. `Authorization: Bearer {token}`ヘッダーが正しく設定されているか確認
3. トークンをリフレッシュ

### データベース接続エラー

**症状**: `SqlException: A network-related or instance-specific error occurred`

**原因**:
- Docker Composeが起動していない
- 接続文字列が間違っている

**解決方法**:
1. `docker-compose ps`でコンテナの状態を確認
2. `docker-compose up -d`で再起動
3. 接続文字列を確認

---

## 参考資料

### ドキュメント

- [要件定義.md](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/要件定義.md)
- [クラス図.drawio](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/UML/クラス図.drawio)
- [シーケンス図.drawio](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/UML/シーケンス図.drawio)
- [アーキテクチャ構成.drawio](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/UML/アーキテクチャ構成.drawio)

### 外部リンク

- [ASP.NET Core SignalR](https://learn.microsoft.com/ja-jp/aspnet/core/signalr/introduction)
- [Next.js Documentation](https://nextjs.org/docs)
- [Zustand Documentation](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [Microsoft SignalR Client for JavaScript](https://www.npmjs.com/package/@microsoft/signalr)
- [Azure App Service Documentation](https://learn.microsoft.com/ja-jp/azure/app-service/)
