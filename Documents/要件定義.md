# Poke-clone-v3 要件定義

## システム作成の目的

### WebSocket を利用した他ユーザとの対戦機能の実装

poke-clone-v1, v2 では、他ユーザとの対戦機能が実装されていなかったため、今回は WebSocket を利用してリアルタイムで他ユーザと対戦できる機能を実装する.

### poke-clone のシステム構成の見直し

poke-clone-v1, v2 では、システム設計に関する資料が甘くその場その場での定義が多く、あとから混乱してしまうことがあったため今回は設計 → 実装の流れを徹底したい.Storybook, ESLint, Prettier などのツールを利用して、保守性の高いコードを書くことを目指す.
また CI/CD の導入も行い、開発工程の一部自動化を目指す.

## 機能要件

| 機能名             | 概要                                           |
| ------------------ | ---------------------------------------------- |
| ユーザ認証         | ユーザの新規登録, ログイン                     |
| ポケモン情報       | ポケモンに関するデータのやり取り               |
| 手持ちポケモン情報 | ユーザの手持ちポケモンに関するデータのやり取り |
| ポケモンバトル     | 野生・または他ユーザとのポケモンバトル         |

## 非機能要件

| 項目                         | 内容                                                            |
| ---------------------------- | --------------------------------------------------------------- |
| フロントエンド開発言語       | TypeScript                                                      |
| フロントエンドフレームワーク | Next.js v16                                                     |
| スタイルライブラリ           | Tailwind CSS                                                         |
| バックエンド開発言語         | C#                                                              |
| バックエンドフレームワーク   | ASP.NET Core 8                                                  |
| データベース                 | Azure SQL Database                                              |
| ORM                          | Entity Framework Core                                           |
| ポケモンデータ               | PokeAPI                                                         |
| API                          | Azure API Management                                            |
| WebSocket                    | Azure SignalR Service                                           |
| ホスティング                 | Vercel                                                          |
| CI/CD                        | GitHub Actions                                                  |
| テスト                       | React Testing Library, Dredd                                    |
| 認証                         | Microsoft Entra External ID にて Google, Microsoft, ID での認証 |
| 認証情報(JWT)の保存          | 　 HttpOnly クッキー                                            |

## 対戦の処理手順

| ステップ             | アクター         | 処理内容 | Redis |
| ------------------ | ------------------ | ------------------ | ------------------ |
| ステップ１： 対戦開始 | プレイヤー | フロントエンドからバックエンドへPOSTでWebSocketへの接続リクエストを送信 | null |
| ステップ２： 対戦データの作成・送信 | `InitState()` | 対戦用データをキャッシュ(`SaveAsync()`)・WebSocketにて対戦用データを送信(`SendAsync()`) | BattleState: null → BattleState(Action以外のStateを設定) |
| ステップ３： 対戦データの受信 | フロントエンド | WebSocketにて送信されたJSONを元に対戦画面を再レンダリング | 変化無し |
| ステップ4: コマンドの選択 | プレイヤー | フロントエンドがPOSTへ`PlayerAction`形式で選択コマンドを送信・ボタンを Disable にする(curlはやめろ) | 変化無し |
| ステップ5-1: コマンドの保存 | `SubmitState()` | RedisへPlayerState.PlayerId == PlayerId となる PlayerState.Actionを変更 | PlayerAction: null → PlayerAction(ステップ5終了までロック) |
| ステップ5-2: コマンドの検証 | `SubmitState()` | RedisのPlayerState.Action1, 2が両方有効な場合には`Battle.ProcessTurn()`を呼び出す | ロック |
| ステップ5-3: 対戦の準備 | `ProcessTurn()` | Redisより取得したPlayerId, PokemonId, PokemonSpeciesId, MoveIdを利用してBattleクラスをインスタンス化 | `BattleHub.RedisBattleRepository.LoadAsync()`にてポケモンデータを取得 |
| ステップ5-4: 対戦ロジックの開始 | `ProcessTurn()` | `Pokemon.Level, Pokemon.BaseSpeed`を取得,`StatCalculator()`にてポケモンの素早さを判定 | ロック中 |
| ステップ5-5: ダメージの計算 | `ProcessTurn()` | `Pokeon.level`, `Pokemon.BaseAttack`, `Pokemon.BaseDefence`, `Pokemon.Type`, `Move.Power`を取得, `StatCalculator()`, `TypeEffectiveManager()`で計算の補助, `DamageCalculator()`でダメージを計算. | ロック中 |
| ステップ5-6: 状態の保存 | `SubmitState` | `DamageCalculator()`の計算結果をRedisへ保存 | PlayerAction以外へ書き込み |
| ステップ5-7: 結果の送信 | `SubmitState` | 処理結果をフロントエンドへSignalRを利用し返却 | PlayerActionのみロック |
| ステップ5-8: ロックの解除 | `SubmitState` | PlayerActionを受け付けるようにロックを解除, PlayerActionを初期化 | PlayerAction: PlayerAction → null |

※ 実際にはロックすると面倒なので, Redisの WATCH または Luaスクリプトを用いた楽観ロックを利用(?)
