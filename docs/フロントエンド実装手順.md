# フロントエンド実装手順書

## 目次

1. [概要](#概要)
2. [バックエンドAPI仕様](#バックエンドapi仕様)
3. [バックエンドクラス・メソッド詳細](#バックエンドクラスメソッド詳細)
4. [フロントエンド実装ステップ](#フロントエンド実装ステップ)
5. [SignalR（WebSocket）による対戦フロー](#signalrwebsocketによる対戦フロー)
6. [状態管理の設計](#状態管理の設計)
7. [UI/UXの実装ガイド](#uiuxの実装ガイド)

---

## 概要

本ドキュメントは、ポケモンクローンゲームのバトルシステムをフロントエンドで実装するための手順書です。バックエンドのAPIとSignalRを活用し、リアルタイム対戦機能を実現します。

### システム構成

```
┌─────────────────┐         ┌──────────────────┐         ┌─────────────┐
│  React/Next.js  │  HTTP   │   ASP.NET Core   │  Redis  │   Redis     │
│   フロント      ├────────►│   WebAPI         ├────────►│   Cache     │
│                 │◄────────┤   + SignalR Hub  │         └─────────────┘
└─────────────────┘ SignalR └──────────────────┘
                              ↓
                         ┌──────────────────┐
                         │  SQL Server DB   │
                         └──────────────────┘
```

---

## バックエンドAPI仕様

### 認証API

#### POST `/api/Auth/login/mock`

**用途**: 開発用モック認証（本番では実装が必要）

**リクエスト**:
```json
{
  "username": "testplayer1",
  "password": "testpassword"
}
```

**レスポンス**:
```json
{
  "message": "Logged in",
  "username": "testplayer1",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Auth/login/mock \
  -H "Content-Type: application/json" \
  -d '{"username": "testplayer1", "password": "testpassword"}'
```

**使用方法**:
1. JWTトークンを取得
2. トークンをローカルストレージまたはCookieに保存（レスポンスにはCookieも自動設定されます）
3. 以降のAPIリクエストで`Authorization: Bearer {token}`ヘッダーを付与

#### POST `/api/Auth/logout`

**用途**: ログアウト（Cookieからトークンを削除）

**リクエスト**: なし

**レスポンス**:
```json
{
  "message": "Logged out"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Auth/logout \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### GET `/api/Auth/status`

**用途**: 現在の認証状態を確認

**リクエスト**: なし

**レスポンス**:
```json
{
  "isAuthenticated": true,
  "userId": "user-uuid-1234",
  "name": "testplayer1",
  "message": "Authenticated"
}
```

**curlテスト例**:
```bash
# 認証なし
curl -X GET http://localhost:5278/api/Auth/status

# 認証あり
curl -X GET http://localhost:5278/api/Auth/status \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### プレイヤーAPI

#### GET `/api/Player/me`

**用途**: 認証済みユーザーのプレイヤー情報を取得

**リクエスト**: なし（認証必須）

**レスポンス例**:
```json
{
  "playerId": "user-uuid-1234",
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Player/me \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### POST `/api/Player/me`

**用途**: プレイヤー情報の作成または更新

**リクエスト**:
```json
{
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**レスポンス例**:
```json
{
  "playerId": "user-uuid-1234",
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Player/me \
  -H "Authorization: Bearer {YOUR_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"name": "サトシ", "iconUrl": "https://example.com/icon.png"}'
```

---

### パーティAPI

#### GET `/api/Party`

**用途**: プレイヤーのパーティ一覧を取得

**リクエスト**: なし（認証必須）

**レスポンス例**:
```json
[
  {
    "pokemonId": "poke001",
    "pokemonSpeciesId": 25,
    "level": 25,
    "exp": 0,
    "moves": [
      {
        "moveId": 1,
        "name": "でんきショック",
        "type": "Electric",
        "damageClass": "Special",
        "power": 40,
        "accuracy": 100,
        "pp": 30
      }
    ]
  }
]
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Party \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### DELETE `/api/Party/{pokemonId}`

**用途**: ポケモンを逃がす（パーティから削除）

**リクエスト**: なし（認証必須）

**レスポンス例**:
```json
{
  "message": "ポケモンを逃がしました"
}
```

**curlテスト例**:
```bash
curl -X DELETE http://localhost:5278/api/Party/{pokemonId} \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### スターターAPI

#### GET `/api/Starter/options`

**用途**: スターターポケモンの選択肢を取得

**リクエスト**: なし（認証必須）

**レスポンス例**:
```json
[
  {
    "pokemonSpeciesId": 390,
    "name": "ヒコザル",
    "frontImage": "/images/390_front.png",
    "backImage": "/images/390_back.png",
    "type1": "Fire",
    "type2": null,
    "baseHp": 44,
    "baseAttack": 58,
    "baseDefence": 44,
    "baseSpecialAttack": 58,
    "baseSpecialDefence": 44,
    "baseSpeed": 61,
    "moveList": []
  },
  {
    "pokemonSpeciesId": 7,
    "name": "ゼニガメ",
    "frontImage": "/images/7_front.png",
    "backImage": "/images/7_back.png",
    "type1": "Water",
    "type2": null,
    "baseHp": 44,
    "baseAttack": 48,
    "baseDefence": 65,
    "baseSpecialAttack": 50,
    "baseSpecialDefence": 64,
    "baseSpeed": 43,
    "moveList": []
  },
  {
    "pokemonSpeciesId": 495,
    "name": "ツタージャ",
    "frontImage": "/images/495_front.png",
    "backImage": "/images/495_back.png",
    "type1": "Grass",
    "type2": null,
    "baseHp": 45,
    "baseAttack": 45,
    "baseDefence": 55,
    "baseSpecialAttack": 45,
    "baseSpecialDefence": 55,
    "baseSpeed": 63,
    "moveList": []
  }
]
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Starter/options \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### POST `/api/Starter/select`

**用途**: スターターポケモンを選択

**リクエスト**:
```json
{
  "pokemonSpeciesId": 390
}
```

**レスポンス例**:
```json
{
  "message": "スターターポケモンを選択しました",
  "pokemon": {
    "pokemonId": "poke-uuid-1234",
    "pokemonSpeciesId": 390,
    "level": 5,
    "exp": 0,
    "moves": [
      {
        "moveId": 52,
        "name": "ひっかく",
        "type": "Normal",
        "damageClass": "Physical",
        "power": 40,
        "accuracy": 100,
        "pp": 35
      }
    ]
  }
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Starter/select \
  -H "Authorization: Bearer {YOUR_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"pokemonSpeciesId": 390}'
```

---

### バトルAPI

#### POST `/api/Battle/cpu`

**用途**: CPUバトルの作成

**リクエスト**: なし（認証からplayerIdを自動取得）

**レスポンス例**:
```json
{
  "battleId": "battle-uuid-1234",
  "player1": {
    "playerId": "user-uuid-1234",
    "player": {
      "playerId": "user-uuid-1234",
      "name": "サトシ",
      "iconUrl": "https://example.com/icon.png"
    },
    "activePokemonIndex": 0,
    "party": [
      {
        "pokemonId": "poke001",
        "pokemonSpeciesId": 25,
        "currentHp": 95,
        "maxHp": 95,
        "ailment": "None",
        "rank": {
          "attack": 0,
          "defence": 0,
          "specialAttack": 0,
          "specialDefence": 0,
          "speed": 0,
          "accuracy": 0,
          "evasion": 0
        }
      }
    ],
    "action": null
  },
  "player2": {
    "playerId": "cpu",
    "player": {
      "playerId": "cpu",
      "name": "CPU",
      "iconUrl": null
    },
    "activePokemonIndex": 0,
    "party": [
      {
        "pokemonId": "cpu-poke001",
        "pokemonSpeciesId": 19,
        "currentHp": 60,
        "maxHp": 60,
        "ailment": "None",
        "rank": {
          "attack": 0,
          "defence": 0,
          "specialAttack": 0,
          "specialDefence": 0,
          "speed": 0,
          "accuracy": 0,
          "evasion": 0
        }
      }
    ],
    "action": null
  },
  "turn": 0,
  "createdAt": "2025-12-05T01:00:00Z",
  "expireAt": "2025-12-05T02:00:00Z"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Battle/cpu \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### GET `/api/Battle/{battleId}`

**用途**: 現在のバトル状態を取得

**リクエスト**: なし（認証必須）

**レスポンス**: `/api/Battle/cpu`と同様

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Battle/{battleId} \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

## バックエンドクラス・メソッド詳細

### 1. BattleHub (SignalR Hub)

**ファイルパス**: `Server.WebAPI/Hubs/BattleHub.cs`

#### 重要メソッド

##### `InitBattle(string battleId)`

**目的**: バトルルームへの接続

**動作**:
1. クライアントを指定されたバトルIDのグループに追加
2. バトル状態をRedisから取得してクライアントに送信

**フロントエンド実装**:
```typescript
// SignalR接続確立後に呼び出す
await connection.invoke("InitBattle", battleId);
```

##### `SubmitAction(string battleId, PlayerAction action)`

**目的**: プレイヤーのアクションを送信

**PlayerAction構造**:
```csharp
public class PlayerAction
{
    public string PlayerId { get; set; }
    public ActionType ActionType { get; set; }  // Attack, Switch, Catch
    public int? MoveId { get; set; }            // 技ID（攻撃時）
    public int? SwitchPokemonIndex { get; set; } // 交代先（交代時）
}
```

**ActionType列挙型**:
- `Attack`: 技を使用
- `Switch`: ポケモンを交代
- `Catch`: 野生ポケモンを捕獲（CPUバトル時のみ）

**動作**:
1. 両プレイヤーのアクションが揃うまで待機
2. 揃ったら`ProcessTurnAsync()`を呼び出し
3. ターン結果を`ReceiveTurnResult`で全クライアントに配信

**フロントエンド実装**:
```typescript
// 攻撃アクション
const attackAction = {
  playerId: "player1",
  actionType: 0, // Attack
  moveId: 1,
  switchPokemonIndex: null
};

await connection.invoke("SubmitAction", battleId, attackAction);

// 交代アクション
const switchAction = {
  playerId: "player1",
  actionType: 1, // Switch
  moveId: null,
  switchPokemonIndex: 2  // 3番目のポケモンに交代
};

await connection.invoke("SubmitAction", battleId, switchAction);
```

##### `ReceiveTurnResult` (クライアント受信)

**目的**: ターン処理結果の受信

**ProcessResult構造**:
```typescript
interface ProcessResult {
  actionResults: ActionResult[];
  isBattleEnd: boolean;
  winnerId: string;
}

interface ActionResult {
  actionPokemonId: string;
  actionType: number;  // 0: Attack, 1: Switch, 2: Catch
  moveResult?: MoveResult;
  switchResult?: SwitchResult;
  catchResult?: CatchResult;
}

interface MoveResult {
  moveId: number;
  targetId: string;
  isSuccess: boolean;
  failureReason: string;
  damage: number;
  hitContext?: {
    isCritical: boolean;
    typeEffectiveness: number;  // 0.25, 0.5, 1.0, 2.0, 4.0
  };
  sourceRankChange?: Rank;
  targetRankChange?: Rank;
  ailment?: string;  // "None", "Paralysis", "Sleep", etc.
}
```

**フロントエンド実装**:
```typescript
connection.on("ReceiveTurnResult", (result: ProcessResult) => {
  // ターン結果を処理
  result.actionResults.forEach(action => {
    if (action.moveResult) {
      // ダメージアニメーション表示
      displayDamage(action.moveResult.damage);
      
      // HP更新
      updatePokemonHp(action.moveResult.targetId, action.moveResult.damage);
      
      // エフェクト表示
      if (action.moveResult.hitContext?.isCritical) {
        showCriticalEffect();
      }
    }
  });
  
  // バトル終了判定
  if (result.isBattleEnd) {
    showBattleResult(result.winnerId);
  }
});
```

---

### 2. BattleService

**ファイルパス**: `Server.Application/Services/BattleService.cs`

#### 主要メソッド

##### `CreateBattleAsync(string player1Id, string player2Id)`

**目的**: 対人バトルの初期化

**処理内容**:
1. 両プレイヤーのデータをDBから取得
2. `PlayerState`を作成（各ポケモンのHPを最大値で初期化）
3. `BattleState`を作成してRedisに保存
4. バトルIDを生成して返却

##### `CreateCpuBattleAsync(string playerId)`

**目的**: CPUバトルの初期化

**処理内容**:
1. プレイヤーのデータをDBから取得
2. CPUプレイヤーを作成（簡易実装、拡張可能）
3. バトル状態を初期化してRedisに保存

##### `ProcessTurnAsync(string battleId, PlayerAction action1, PlayerAction action2)`

**目的**: 1ターンの処理実行

**処理フロー**:
```
1. Redisで分散ロック取得（同時実行防止）
   ↓
2. BattleStateをRedisから取得
   ↓
3. Battleドメインオブジェクトを生成
   ↓
4. Battle.ProcessTurn(action1, action2)を実行
   ├─ 素早さ判定で行動順決定
   ├─ アクション1実行
   │  ├─ 攻撃: ダメージ計算、命中判定、タイプ相性
   │  ├─ 交代: ポケモン交代処理
   │  └─ 捕獲: 捕獲判定
   └─ アクション2実行（同様）
   ↓
5. ダメージをPlayerState.Party[].CurrentHpに反映
   ↓
6. 全ポケモン瀕死判定（IsBattleEnd, WinnerId設定）
   ↓
7. ターン数インクリメント
   ↓
8. 更新されたBattleStateをRedisに保存
   ↓
9. ProcessResultを返却
   ↓
10. Redisロック解放
```

---

### 3. Battle (ドメインモデル)

**ファイルパス**: `Server.Domain/Battle.cs`

#### コンストラクタ

```csharp
public Battle(
    IDamageCalculator damageCalculator,
    ITypeEffectivenessManager typeEffectivenessManager,
    IStatCalculator statCalculator,
    BattlePlayer player1,
    BattlePlayer player2)
```

#### `ProcessTurn(PlayerAction action1, PlayerAction action2)`

**目的**: ターン処理のコアロジック

**処理詳細**:

1. **行動順決定**:
   - 優先度: 交代 > 攻撃
   - 同優先度の場合: 素早さの高い方が先行
   - 素早さ同値: ランダム

2. **攻撃処理** (`ProcessMoveAction`):
   ```
   ① 命中判定（Accuracy: 1-100の乱数）
   ② タイプ相性計算（0.25倍～4倍）
   ③ ダメージ計算式:
      damage = ((level × 2 ÷ 5 + 2) × power × attack ÷ defence ÷ 50 + 2)
               × random(85-100) ÷ 100
               × typeEffectiveness
               × (critical ? 1.5 : 1.0)
   ④ 急所判定（1/16の確率）
   ⑤ ランク補正計算
   ⑥ MoveResult生成
   ```

3. **交代処理** (`ProcessSwitchAction`):
   ```
   ① 交代先インデックスの妥当性確認
   ② ActivePokemonIndexを更新
   ③ SwitchResult生成
   ```

4. **捕獲処理** (`ProcessCatchAction`):
   ```
   ① 捕獲率計算（HP依存）
   ② ランダム判定
   ③ 成功時は対象ポケモンをPlayer1のパーティに追加
   ④ CatchResult生成
   ```

---

### 4. エンティティクラス

#### BattleState

**構造**:
```csharp
public class BattleState
{
    public string BattleId { get; set; }
    public PlayerState Player1 { get; set; }
    public PlayerState Player2 { get; set; }
    public int Turn { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ExpireAt { get; set; }
}
```

**Redis保存**: JSON形式でシリアライズして保存

#### PlayerState

**構造**:
```csharp
public class PlayerState
{
    public string PlayerId { get; set; }
    public Player Player { get; set; }
    public int ActivePokemonIndex { get; set; }
    public List<PokemonState> Party { get; set; }
    public List<Pokemon> PokemonEntities { get; set; }  // Battle計算用
    public PlayerAction? Action { get; set; }
    
    // 便利プロパティ
    public bool AllPokemonFainted => Party.All(p => p.IsFainted);
    public PokemonState ActivePokemon => Party[ActivePokemonIndex];
}
```

#### PokemonState

**構造**:
```csharp
public class PokemonState
{
    public string PokemonId { get; set; }
    public int PokemonSpeciesId { get; set; }
    public int CurrentHp { get; set; }
    public int MaxHp { get; set; }
    public Ailment Ailment { get; set; }  // None, Paralysis, Sleep, etc.
    public Rank Rank { get; set; }
    
    // 便利プロパティ
    public bool IsFainted => CurrentHp <= 0;
}
```

**重要**: `CurrentHp`がバトル中の現在HPを表し、ダメージを受けるたびに減少します。

---

## フロントエンド実装ステップ

### Step 1: プロジェクトセットアップ

#### 必要なライブラリ

```bash
# Next.js（推奨）
npx create-next-app@latest poke-clone-frontend --typescript

# または React
npx create-react-app poke-clone-frontend --template typescript

# SignalR クライアント
npm install @microsoft/signalr

# 状態管理（Zustand推奨）
npm install zustand

# APIクライアント
npm install axios

# スタイリング
npm install tailwindcss @tailwindcss/forms

# Storybook のセットアップ
npx storybook@latest init

# または手動でインストール
npm install --save-dev @storybook/react @storybook/addon-essentials @storybook/addon-interactions @storybook/addon-links @storybook/blocks @storybook/test
```

#### Storybookのセットアップ

Storybookは、UIコンポーネントを独立した環境で開発・テストするためのツールです。

##### 1. Storybookの初期化

```bash
# プロジェクトルートで実行
npx storybook@latest init
```

このコマンドは自動的に以下を行います:
- 必要な依存関係のインストール
- `.storybook/` ディレクトリの作成
- サンプルストーリーの生成
- `package.json` へのスクリプト追加

##### 2. Storybookの設定

**`.storybook/main.js`** (または `.ts`):

```javascript
module.exports = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@storybook/addon-links',
  ],
  framework: {
    name: '@storybook/react-vite', // または '@storybook/react-webpack5'
    options: {},
  },
  docs: {
    autodocs: 'tag',
  },
};
```

**`.storybook/preview.js`**:

```javascript
import '../src/index.css'; // グローバルスタイルをインポート

export const parameters = {
  actions: { argTypesRegex: '^on[A-Z].*' },
  controls: {
    matchers: {
      color: /(background|color)$/i,
      date: /Date$/,
    },
  },
};
```

##### 3. コンポーネントストーリーの作成例

**`src/components/Battle/HPBar.stories.tsx`**:

```typescript
import type { Meta, StoryObj } from '@storybook/react';
import { HPBar } from './HPBar';

const meta: Meta<typeof HPBar> = {
  title: 'Battle/HPBar',
  component: HPBar,
  tags: ['autodocs'],
  argTypes: {
    currentHp: { control: { type: 'number', min: 0, max: 100 } },
    maxHp: { control: { type: 'number', min: 1, max: 100 } },
  },
};

export default meta;
type Story = StoryObj<typeof HPBar>;

export const Full: Story = {
  args: {
    currentHp: 100,
    maxHp: 100,
  },
};

export const Half: Story = {
  args: {
    currentHp: 50,
    maxHp: 100,
  },
};

export const Low: Story = {
  args: {
    currentHp: 15,
    maxHp: 100,
  },
};

export const Critical: Story = {
  args: {
    currentHp: 5,
    maxHp: 100,
  },
};
```

**`src/components/Battle/PokemonDisplay.stories.tsx`**:

```typescript
import type { Meta, StoryObj } from '@storybook/react';
import { PokemonDisplay } from './PokemonDisplay';

const meta: Meta<typeof PokemonDisplay> = {
  title: 'Battle/PokemonDisplay',
  component: PokemonDisplay,
  tags: ['autodocs'],
};

export default meta;
type Story = StoryObj<typeof PokemonDisplay>;

export const Pikachu: Story = {
  args: {
    pokemon: {
      pokemonId: 'poke001',
      pokemonSpeciesId: 25,
      currentHp: 95,
      maxHp: 95,
      ailment: 'None',
      rank: {
        attack: 0,
        defence: 0,
        specialAttack: 0,
        specialDefence: 0,
        speed: 0,
        accuracy: 0,
        evasion: 0,
      },
    },
    species: {
      pokemonSpeciesId: 25,
      name: 'ピカチュウ',
      frontImage: '/images/pikachu_front.png',
      backImage: '/images/pikachu_back.png',
      type1: 'Electric',
      type2: null,
      baseHp: 35,
      baseAttack: 55,
      baseDefence: 40,
      baseSpecialAttack: 50,
      baseSpecialDefence: 50,
      baseSpeed: 90,
    },
    isPlayer: true,
  },
};

export const OpponentCharizard: Story = {
  args: {
    pokemon: {
      pokemonId: 'poke002',
      pokemonSpeciesId: 6,
      currentHp: 78,
      maxHp: 78,
      ailment: 'None',
      rank: {
        attack: 0,
        defence: 0,
        specialAttack: 0,
        specialDefence: 0,
        speed: 0,
        accuracy: 0,
        evasion: 0,
      },
    },
    species: {
      pokemonSpeciesId: 6,
      name: 'リザードン',
      frontImage: '/images/charizard_front.png',
      backImage: '/images/charizard_back.png',
      type1: 'Fire',
      type2: 'Flying',
      baseHp: 78,
      baseAttack: 84,
      baseDefence: 78,
      baseSpecialAttack: 109,
      baseSpecialDefence: 85,
      baseSpeed: 100,
    },
    isPlayer: false,
  },
};
```

##### 4. Storybookの起動

```bash
# 開発モードで起動
npm run storybook

# ビルド（静的ファイル生成）
npm run build-storybook
```

デフォルトでは `http://localhost:6006` でStorybookが起動します。

##### 5. ストーリー作成のベストプラクティス

- **コンポーネントごとにストーリーを作成**: 各UIコンポーネントに対応する `.stories.tsx` ファイルを作成
- **複数の状態を表現**: 正常状態、エラー状態、ローディング状態など、様々な状態のストーリーを用意
- **Argsを活用**: `args` を使ってプロパティを動的に変更可能にする
- **Actionsを使用**: ユーザーインタラクション（クリック、入力など）をログに記録
- **Autodocsを有効化**: `tags: ['autodocs']` でドキュメントを自動生成

---

#### プロジェクト構造（Storybook追加後）

```
src/
├── components/
│   ├── Battle/
│   │   ├── BattleField.tsx
│   │   ├── BattleField.stories.tsx      # 追加
│   │   ├── PokemonDisplay.tsx
│   │   ├── PokemonDisplay.stories.tsx   # 追加
│   │   ├── HPBar.tsx
│   │   ├── HPBar.stories.tsx            # 追加
│   │   ├── MoveSelector.tsx
│   │   ├── MoveSelector.stories.tsx     # 追加
│   │   ├── PokemonSelector.tsx
│   │   ├── PokemonSelector.stories.tsx  # 追加
│   │   ├── BattleLog.tsx
│   │   ├── BattleLog.stories.tsx        # 追加
│   │   └── TypeEffectivenessIcon.tsx
│   │       └── TypeEffectivenessIcon.stories.tsx  # 追加
│   └── Auth/
│       ├── Login.tsx
│       └── Login.stories.tsx            # 追加
├── hooks/
│   ├── useBattle.ts
│   ├── useSignalR.ts
│   └── useAuth.ts
├── services/
│   ├── api.ts
│   └── signalr.ts
├── stores/
│   ├── battleStore.ts
│   └── authStore.ts
├── types/
│   ├── battle.ts
│   ├── pokemon.ts
│   └── action.ts
└── utils/
    ├── typeEffectiveness.ts
    └── damageCalculator.ts

.storybook/                              # 追加
├── main.js                              # Storybook設定
└── preview.js                           # グローバル設定・デコレーター
```





---

### Step 2: 型定義

**`types/battle.ts`**:

```typescript
export interface BattleState {
  battleId: string;
  player1: PlayerState;
  player2: PlayerState;
  turn: number;
  createdAt: string;
  expireAt?: string;
}

export interface PlayerState {
  playerId: string;
  player: Player;
  activePokemonIndex: number;
  party: PokemonState[];
  action?: PlayerAction;
}

export interface PokemonState {
  pokemonId: string;
  pokemonSpeciesId: number;
  currentHp: number;
  maxHp: number;
  ailment: Ailment;
  rank: Rank;
  isFainted?: boolean;
}

export interface Player {
  playerId: string;
  name: string;
  iconUrl?: string;
}

export interface Rank {
  attack: number;
  defence: number;
  specialAttack: number;
  specialDefence: number;
  speed: number;
  accuracy: number;
  evasion: number;
}

export type Ailment = 
  | 'None' 
  | 'Paralysis' 
  | 'Sleep' 
  | 'Freeze' 
  | 'Burn' 
  | 'Poison' 
  | 'DeadlyPoisoned';

// PokemonStat型の定義（ステータス変化用）
export type PokemonStat = 
  | 'attack' 
  | 'defense' 
  | 'special-attack' 
  | 'special-defense' 
  | 'speed' 
  | 'accuracy' 
  | 'evasion';

// StatChangeインターフェース（技によるステータス変化）
export interface StatChange {
  stat: PokemonStat;
  change: number;  // -6 ~ +6 の範囲
}


export interface PlayerAction {
  playerId: string;
  actionType: ActionType;
  moveId?: number;
  switchPokemonIndex?: number;
}

export enum ActionType {
  Attack = 0,
  Switch = 1,
  Catch = 2
}

export interface ProcessResult {
  actionResults: ActionResult[];
  isBattleEnd: boolean;
  winnerId: string;
}

export interface ActionResult {
  actionPokemonId: string;
  actionType: ActionType;
  moveResult?: MoveResult;
  switchResult?: SwitchResult;
  catchResult?: CatchResult;
}

export interface MoveResult {
  moveId: number;
  targetId: string;
  isSuccess: boolean;
  failureReason: string;
  damage: number;
  hitContext?: {
    isCritical: boolean;
    typeEffectiveness: number;
  };
  sourceRankChange?: Rank;
  targetRankChange?: Rank;
  ailment?: string;
  // ステータス変化の追加（ランク記録とは別に証跡を保持）
  sourceStatChanges?: StatChange[];  // 攻撃者のステータス変化
  targetStatChanges?: StatChange[];  // 対象のステータス変化
  // HP回復関連
  healing?: number;   // 回復量（自分のHP回復）
  drain?: number;     // 吸収量（相手に与えたダメージを吸収）
}


export interface SwitchResult {
  currentPokemonId: string;
  nextPokemonId: string;
}

export interface CatchResult {
  isSuccess: boolean;
  caughtPokemonId: string;
}
```

---

### Step 3: SignalR接続管理

**`services/signalr.ts`**:

```typescript
import * as signalR from '@microsoft/signalr';

class SignalRService {
  private connection: signalR.HubConnection | null = null;
  
  async connect(token: string): Promise<signalR.HubConnection> {
    if (this.connection) {
      return this.connection;
    }
    
    this.connection = new signalR.HubConnectionBuilder()
      .withUrl('http://localhost:5000/hubs/battle', {
        accessTokenFactory: () => token,
        transport: signalR.HttpTransportType.WebSockets
      })
      .withAutomaticReconnect()
      .configureLogging(signalR.LogLevel.Information)
      .build();
    
    await this.connection.start();
    console.log('SignalR Connected');
    
    return this.connection;
  }
  
  async disconnect(): Promise<void> {
    if (this.connection) {
      await this.connection.stop();
      this.connection = null;
      console.log('SignalR Disconnected');
    }
  }
  
  getConnection(): signalR.HubConnection | null {
    return this.connection;
  }
}

export const signalRService = new SignalRService();
```

---

### Step 4: カスタムフック

**`hooks/useSignalR.ts`**:

```typescript
import { useEffect, useState } from 'react';
import { signalRService } from '@/services/signalr';
import { ProcessResult } from '@/types/battle';
import * as signalR from '@microsoft/signalr';

export const useSignalR = (
  battleId: string,
  token: string,
  onTurnResult: (result: ProcessResult) => void
) => {
  const [connection, setConnection] = useState<signalR.HubConnection | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const setupConnection = async () => {
      try {
        const conn = await signalRService.connect(token);
        
        // ターン結果受信ハンドラ
        conn.on('ReceiveTurnResult', (result: ProcessResult) => {
          console.log('Turn result received:', result);
          onTurnResult(result);
        });
        
        // バトル状態受信ハンドラ
        conn.on('ReceiveBattleState', (state: any) => {
          console.log('Battle state received:', state);
        });
        
        // バトル初期化
        await conn.invoke('InitBattle', battleId);
        
        setConnection(conn);
        setIsConnected(true);
      } catch (err) {
        console.error('SignalR connection error:', err);
        setError(err instanceof Error ? err.message : 'Unknown error');
      }
    };
    
    setupConnection();
    
    return () => {
      signalRService.disconnect();
    };
  }, [battleId, token]);
  
  const submitAction = async (action: PlayerAction) => {
    if (!connection) {
      throw new Error('SignalR not connected');
    }
    
    try {
      await connection.invoke('SubmitAction', battleId, action);
    } catch (err) {
      console.error('Failed to submit action:', err);
      throw err;
    }
  };
  
  return { connection, isConnected, error, submitAction };
};
```

---

### Step 5: バトル状態管理

**`stores/battleStore.ts`** (Zustand使用):

```typescript
import { create } from 'zustand';
import { BattleState, ProcessResult, PokemonState } from '@/types/battle';

interface BattleStore {
  battleState: BattleState | null;
  turnResult: ProcessResult | null;
  battleLog: string[];
  isWaitingForOpponent: boolean;
  
  setBattleState: (state: BattleState) => void;
  setTurnResult: (result: ProcessResult) => void;
  addLog: (message: string) => void;
  clearLog: () => void;
  updatePokemonHp: (pokemonId: string, damage: number) => void;
  setWaitingForOpponent: (waiting: boolean) => void;
  resetBattle: () => void;
}

export const useBattleStore = create<BattleStore>((set) => ({
  battleState: null,
  turnResult: null,
  battleLog: [],
  isWaitingForOpponent: false,
  
  setBattleState: (state) => set({ battleState: state }),
  
  setTurnResult: (result) => set({ turnResult: result }),
  
  addLog: (message) => set((state) => ({
    battleLog: [...state.battleLog, message]
  })),
  
  clearLog: () => set({ battleLog: [] }),
  
  updatePokemonHp: (pokemonId, damage) => set((state) => {
    if (!state.battleState) return state;
    
    const updateParty = (party: PokemonState[]) =>
      party.map(p => 
        p.pokemonId === pokemonId
          ? { ...p, currentHp: Math.max(0, p.currentHp - damage) }
          : p
      );
    
    return {
      battleState: {
        ...state.battleState,
        player1: {
          ...state.battleState.player1,
          party: updateParty(state.battleState.player1.party)
        },
        player2: {
          ...state.battleState.player2,
          party: updateParty(state.battleState.player2.party)
        }
      }
    };
  }),
  
  setWaitingForOpponent: (waiting) => set({ isWaitingForOpponent: waiting }),
  
  resetBattle: () => set({
    battleState: null,
    turnResult: null,
    battleLog: [],
    isWaitingForOpponent: false
  })
}));
```

---

### Step 6: コンポーネント実装

#### BattleField.tsx

```typescript
import React, { useEffect, useState } from 'react';
import { useSignalR } from '@/hooks/useSignalR';
import { useBattleStore } from '@/stores/battleStore';
import { PokemonDisplay } from './PokemonDisplay';
import { HPBar } from './HPBar';
import { MoveSelector } from './MoveSelector';
import { BattleLog } from './BattleLog';
import { ActionType, PlayerAction } from '@/types/battle';

interface BattleFieldProps {
  battleId: string;
  playerId: string;
  token: string;
}

export const BattleField: React.FC<BattleFieldProps> = ({
  battleId,
  playerId,
  token
}) => {
  const { battleState, turnResult, addLog, updatePokemonHp, setWaitingForOpponent } = useBattleStore();
  const [selectedMove, setSelectedMove] = useState<number | null>(null);
  
  const handleTurnResult = (result: ProcessResult) => {
    // ログ追加
    result.actionResults.forEach(action => {
      if (action.moveResult) {
        const move = action.moveResult;
        addLog(`${move.damage}ダメージ！`);
        
        if (move.hitContext?.isCritical) {
          addLog('急所に当たった！');
        }
        
        if (move.hitContext?.typeEffectiveness > 1) {
          addLog('効果は抜群だ！');
        } else if (move.hitContext?.typeEffectiveness < 1) {
          addLog('効果はいまひとつのようだ...');
        }
        
        // HP更新
        updatePokemonHp(move.targetId, move.damage);
      }
    });
    
    // バトル終了判定
    if (result.isBattleEnd) {
      const isWinner = result.winnerId === playerId;
      addLog(isWinner ? 'あなたの勝ちです！' : 'あなたの負けです...');
    }
    
    setWaitingForOpponent(false);
  };
  
  const { isConnected, submitAction } = useSignalR(
    battleId,
    token,
    handleTurnResult
  );
  
  const handleMoveSelect = async (moveId: number) => {
    const action: PlayerAction = {
      playerId,
      actionType: ActionType.Attack,
      moveId
    };
    
    await submitAction(action);
    setWaitingForOpponent(true);
    addLog('相手の行動を待っています...');
  };
  
  if (!isConnected || !battleState) {
    return <div>接続中...</div>;
  }
  
  const isMyTurn = battleState.player1.playerId === playerId;
  const myState = isMyTurn ? battleState.player1 : battleState.player2;
  const opponentState = isMyTurn ? battleState.player2 : battleState.player1;
  
  const myPokemon = myState.party[myState.activePokemonIndex];
  const opponentPokemon = opponentState.party[opponentState.activePokemonIndex];
  
  return (
    <div className="battle-field">
      {/* 相手のポケモン */}
      <div className="opponent-area">
        <PokemonDisplay
          pokemon={opponentPokemon}
          isOpponent={true}
        />
        <HPBar
          current={opponentPokemon.currentHp}
          max={opponentPokemon.maxHp}
        />
      </div>
      
      {/* 自分のポケモン */}
      <div className="player-area">
        <PokemonDisplay
          pokemon={myPokemon}
          isOpponent={false}
        />
        <HPBar
          current={myPokemon.currentHp}
          max={myPokemon.maxHp}
          showNumbers={true}
        />
      </div>
      
      {/* コマンド選択 */}
      <div className="command-area">
        <MoveSelector
          moves={myPokemon.moves}
          onMoveSelect={handleMoveSelect}
          disabled={isWaitingForOpponent}
        />
      </div>
      
      {/* バトルログ */}
      <BattleLog />
    </div>
  );
};
```

#### HPBar.tsx

```typescript
import React from 'react';

interface HPBarProps {
  current: number;
  max: number;
  showNumbers?: boolean;
}

export const HPBar: React.FC<HPBarProps> = ({ current, max, showNumbers = false }) => {
  const percentage = (current / max) * 100;
  
  const getBarColor = () => {
    if (percentage > 50) return 'bg-green-500';
    if (percentage > 20) return 'bg-yellow-500';
    return 'bg-red-500';
  };
  
  return (
    <div className="hp-bar">
      <div className="flex justify-between mb-1">
        <span className="text-sm font-semibold">HP</span>
        {showNumbers && (
          <span className="text-sm">{current} / {max}</span>
        )}
      </div>
      <div className="w-full bg-gray-300 rounded-full h-4 overflow-hidden">
        <div
          className={`h-full transition-all duration-500 ${getBarColor()}`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  );
};
```

#### MoveSelector.tsx

```typescript
import React from 'react';
import { Move } from '@/types/pokemon';

interface MoveSelectorProps {
  moves: Move[];
  onMoveSelect: (moveId: number) => void;
  disabled: boolean;
}

export const MoveSelector: React.FC<MoveSelectorProps> = ({
  moves,
  onMoveSelect,
  disabled
}) => {
  return (
    <div className="grid grid-cols-2 gap-2 p-4">
      {moves.map((move) => (
        <button
          key={move.moveId}
          onClick={() => onMoveSelect(move.moveId)}
          disabled={disabled}
          className={`
            p-4 rounded-lg border-2 text-left
            ${disabled ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-100'}
            ${getTypeColor(move.type)}
          `}
        >
          <div className="font-bold">{move.name}</div>
          <div className="text-sm">
            <span className="mr-2">威力: {move.power}</span>
            <span>PP: {move.pp}</span>
          </div>
          <div className="text-xs mt-1 opacity-75">
            {move.type} / {move.damageClass}
          </div>
        </button>
      ))}
    </div>
  );
};

const getTypeColor = (type: string): string => {
  const colors: Record<string, string> = {
    Normal: 'border-gray-400',
    Fire: 'border-red-500',
    Water: 'border-blue-500',
    Electric: 'border-yellow-400',
    Grass: 'border-green-500',
    Ice: 'border-cyan-300',
    Fighting: 'border-orange-600',
    Poison: 'border-purple-500',
    Ground: 'border-yellow-700',
    Flying: 'border-indigo-300',
    Psychic: 'border-pink-500',
    Bug: 'border-lime-500',
    Rock: 'border-yellow-800',
    Ghost: 'border-purple-700',
    Dragon: 'border-indigo-600',
    Dark: 'border-gray-700',
    Steel: 'border-gray-500',
    Fairy: 'border-pink-300'
  };
  
  return colors[type] || 'border-gray-400';
};
```

---

## SignalR（WebSocket）による対戦フロー

### 完全なバトルフロー図

```
プレイヤー1                SignalR Hub               プレイヤー2
    │                          │                          │
    ├─── InitBattle ──────────>│                          │
    │                          ├─── ReceiveBattleState ──>│
    │<─── ReceiveBattleState ──┤                          │
    │                          │                          │
    ├─── SubmitAction ────────>│                          │
    │     (攻撃選択)            │<─── SubmitAction ────────┤
    │                          │     (攻撃選択)            │
    │                   [両方のアクション揃う]             │
    │                          │                          │
    │                   [ProcessTurnAsync実行]            │
    │                   [ダメージ計算・HP更新]            │
    │                   [勝敗判定]                        │
    │                          │                          │
    │<─ ReceiveTurnResult ─────┼─ ReceiveTurnResult ─────>│
    │    (結果を表示)           │    (結果を表示)          │
    │    (HPバー更新)           │    (HPバー更新)          │
    │    (アニメーション)        │    (アニメーション)       │
    │                          │                          │
    └─────[次のターンへ]────────┴─────[次のターンへ]─────┘
```

### 詳細な実装フロー

#### 1. バトル開始

```typescript
// 1. バトル作成
const response = await axios.post('/api/Battle/create', {
  player1Id: 'player1',
  player2Id: 'player2'
});

const battleId = response.data.battleId;

// 2. SignalR接続
const connection = await signalRService.connect(token);

// 3. バトル初期化
await connection.invoke('InitBattle', battleId);
```

#### 2. アクション送信

```typescript
// プレイヤーが技を選択
const action: PlayerAction = {
  playerId: currentPlayerId,
  actionType: ActionType.Attack,
  moveId: selectedMoveId
};

// SignalRでアクション送信
await connection.invoke('SubmitAction', battleId, action);

// 待機状態表示
setWaitingForOpponent(true);
```

#### 3. ターン結果受信

```typescript
connection.on('ReceiveTurnResult', async (result: ProcessResult) => {
  // アニメーションシーケンス
  for (const actionResult of result.actionResults) {
    if (actionResult.moveResult) {
      // 1. 技名表示
      await showMoveAnimation(actionResult.moveResult.moveId);
      await delay(500);
      
      // 2. ダメージアニメーション
      await animateDamage(
        actionResult.moveResult.targetId,
        actionResult.moveResult.damage
      );
      
      // 3. HP減少アニメーション
      await animateHpDecrease(
        actionResult.moveResult.targetId,
        actionResult.moveResult.damage
      );
      
      // 4. タイプ相性メッセージ
      if (actionResult.moveResult.hitContext) {
        const effectiveness = actionResult.moveResult.hitContext.typeEffectiveness;
        if (effectiveness > 1) {
          await showMessage('効果は抜群だ！');
        } else if (effectiveness < 1) {
          await showMessage('効果はいまひとつのようだ...');
        }
        
        if (actionResult.moveResult.hitContext.isCritical) {
          await showMessage('急所に当たった！');
        }
      }
      
      await delay(1000);
    }
  }
  
  // バトル終了チェック
  if (result.isBattleEnd) {
    const isWinner = result.winnerId === currentPlayerId;
    await showBattleEndScreen(isWinner);
  }
  
  // 次のターン準備
  setWaitingForOpponent(false);
});
```

---

## 状態管理の設計

### 状態の種類

1. **グローバル状態** (Zustand/Redux)
   - `battleState`: 現在のバトル状態
   - `authState`: 認証情報
   - `playerData`: プレイヤー情報

2. **ローカル状態** (useState)
   - `selectedMove`: 選択中の技
   - `isAnimating`: アニメーション実行中フラグ
   - `battleLog`: バトルログメッセージ

3. **サーバー状態** (React Query推奨)
   - バトル一覧
   - プレイヤーパーティ

### 状態同期戦略

```typescript
// バトル状態の同期
useEffect(() => {
  if (turnResult) {
    // ターン結果からローカル状態を更新
    updateLocalBattleState(turnResult);
  }
}, [turnResult]);

const updateLocalBattleState = (result: ProcessResult) => {
  result.actionResults.forEach(action => {
    if (action.moveResult) {
      // HP更新
      updatePokemonHp(
        action.moveResult.targetId,
        action.moveResult.damage
      );
    }
    
    if (action.switchResult) {
      // ポケモン交代
      switchActivePokemon(
        action.switchResult.currentPokemonId,
        action.switchResult.nextPokemonId
      );
    }
  });
};
```

---

## UI/UXの実装ガイド

### アニメーション実装

#### ダメージアニメーション

```typescript
const animateDamage = async (targetId: string, damage: number) => {
  const element = document.getElementById(`pokemon-${targetId}`);
  if (!element) return;
  
  // ダメージ数値表示
  const damageText = document.createElement('div');
  damageText.className = 'damage-text';
  damageText.textContent = `-${damage}`;
  element.appendChild(damageText);
  
  // フラッシュアニメーション
  element.classList.add('damage-flash');
  await delay(100);
  element.classList.remove('damage-flash');
  
  // シェイクアニメーション
  element.classList.add('shake');
  await delay(500);
  element.classList.remove('shake');
  
  // ダメージ数値フェードアウト
  damageText.classList.add('fade-out');
  await delay(500);
  damageText.remove();
};
```

**CSS**:

```css
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-10px); }
  75% { transform: translateX(10px); }
}

.shake {
  animation: shake 0.5s ease-in-out;
}

.damage-flash {
  filter: brightness(2) saturate(0);
}

.damage-text {
  position: absolute;
  font-size: 2rem;
  font-weight: bold;
  color: #ff4444;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  animation: float-up 1s ease-out;
}

@keyframes float-up {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(-50px);
  }
}
```

#### HP減少アニメーション

```typescript
const animateHpDecrease = async (pokemonId: string, damage: number) => {
  const pokemon = getPokemonById(pokemonId);
  if (!pokemon) return;
  
  const startHp = pokemon.currentHp;
  const endHp = Math.max(0, startHp - damage);
  const duration = 1000; // 1秒
  const steps = 60; // 60フレーム
  const decrement = (startHp - endHp) / steps;
  
  for (let i = 0; i < steps; i++) {
    const currentHp = Math.max(endHp, startHp - (decrement * i));
    updatePokemonHpDisplay(pokemonId, currentHp);
    await delay(duration / steps);
  }
  
  updatePokemonHpDisplay(pokemonId, endHp);
};
```

### レスポンシブデザイン

```tsx
// モバイル対応レイアウト
<div className="battle-field grid grid-cols-1 md:grid-cols-2 gap-4">
  <div className="pokemon-area">
    {/* ポケモン表示 */}
  </div>
  <div className="command-area">
    <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
      {/* 技ボタン */}
    </div>
  </div>
</div>
```

### エラーハンドリング

```typescript
// SignalR接続エラー
connection.onclose((error) => {
  console.error('Connection closed:', error);
  showNotification('接続が切断されました。再接続しています...');
  
  // 自動再接続
  setTimeout(() => {
    connection.start();
  }, 5000);
});

// アクション送信エラー
try {
  await connection.invoke('SubmitAction', battleId, action);
} catch (error) {
  console.error('Failed to submit action:', error);
  showNotification('アクションの送信に失敗しました。もう一度お試しください。');
  setWaitingForOpponent(false);
}
```

### パフォーマンス最適化

```typescript
// メモ化
const MoveButton = React.memo(({ move, onSelect }) => {
  return (
    <button onClick={() => onSelect(move.moveId)}>
      {move.name}
    </button>
  );
});

// 仮想スクロール（バトルログ）
import { FixedSizeList } from 'react-window';

const BattleLog = ({ logs }) => {
  return (
    <FixedSizeList
      height={300}
      itemCount={logs.length}
      itemSize={30}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>{logs[index]}</div>
      )}
    </FixedSizeList>
  );
};
```

---

## バトルアニメーションの拡張

サーバー側の更新により、`MoveResult`に以下の情報が追加されました:
- **ステータス変化**: `sourceStatChanges`, `targetStatChanges`
- **HP回復**: `healing`
- **ドレイン（HP吸収）**: `drain`

これらの情報を適切にビジュアル化し、ユーザーエクスペリエンスを向上させます。

### ステータス変化の表示

#### 1. ステータス変化インジケーターコンポーネント

**`components/Battle/StatChangeIndicator.tsx`**:

```typescript
import React from 'react';
import { StatChange } from '@/types/battle';

interface StatChangeIndicatorProps {
  statChanges: StatChange[];
}

const statNameMap: Record<string, string> = {
  'attack': '攻撃',
  'defense': '防御',
  'special-attack': '特攻',
  'special-defense': '特防',
  'speed': '素早さ',
  'accuracy': '命中率',
  'evasion': '回避率'
};

export const StatChangeIndicator: React.FC<StatChangeIndicatorProps> = ({ statChanges }) => {
  if (statChanges.length === 0) return null;

  return (
    <div className="stat-change-container">
      {statChanges.map((change, index) => (
        <div
          key={index}
          className={`stat-change ${change.change > 0 ? 'stat-up' : 'stat-down'}`}
        >
          <span className="stat-name">{statNameMap[change.stat]}</span>
          <span className="stat-arrow">
            {change.change > 0 ? '↑' : '↓'}
          </span>
          <span className="stat-amount">{Math.abs(change.change)}</span>
        </div>
      ))}
    </div>
  );
};
```

**CSS (TailwindまたはVanilla CSS)**:

```css
.stat-change-container {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  animation: fadeInSlide 0.5s ease-out;
}

.stat-change {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 14px;
  font-weight: bold;
}

.stat-up {
  background-color: #4ade80;
  color: white;
}

.stat-down {
  background-color: #f87171;
  color: white;
}

.stat-arrow {
  font-size: 18px;
}

@keyframes fadeInSlide {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
```

#### 2. ターン結果処理でのステータス変化表示

**`hooks/useTurnProcessor.ts`** の更新例:

```typescript
// ProcessResultを処理してアニメーションイベントを生成
const processTurnResult = (result: ProcessResult) => {
  const events: BattleEvent[] = [];

  result.actionResults.forEach((actionResult) => {
    if (actionResult.moveResult) {
      const moveResult = actionResult.moveResult;

      // ダメージアニメーション
      if (moveResult.damage > 0) {
        events.push({
          type: 'damage',
          targetId: moveResult.targetId,
          amount: moveResult.damage,
          isCritical: moveResult.hitContext?.isCritical
        });
      }

      // ステータス変化アニメーション（攻撃者）
      if (moveResult.sourceStatChanges && moveResult.sourceStatChanges.length > 0) {
        events.push({
          type: 'stat-change',
          targetId: actionResult.actionPokemonId,
          statChanges: moveResult.sourceStatChanges
        });
      }

      // ステータス変化アニメーション（対象）
      if (moveResult.targetStatChanges && moveResult.targetStatChanges.length > 0) {
        events.push({
          type: 'stat-change',
          targetId: moveResult.targetId,
          statChanges: moveResult.targetStatChanges
        });
      }

      // 回復アニメーション
      if (moveResult.healing && moveResult.healing > 0) {
        events.push({
          type: 'healing',
          targetId: actionResult.actionPokemonId,
          amount: moveResult.healing
        });
      }

      // ドレインアニメーション
      if (moveResult.drain && moveResult.drain > 0) {
        events.push({
          type: 'drain',
          sourceId: actionResult.actionPokemonId,
          targetId: moveResult.targetId,
          amount: moveResult.drain
        });
      }
    }
  });

  return events;
};
```

### HP回復エフェクトの実装

#### 回復エフェクトコンポーネント

**`components/Battle/HealingEffect.tsx`**:

```typescript
import React from 'react';

interface HealingEffectProps {
  amount: number;
  onComplete: () => void;
}

export const HealingEffect: React.FC<HealingEffectProps> = ({ amount, onComplete }) => {
  React.useEffect(() => {
    const timer = setTimeout(onComplete, 1000);
    return () => clearTimeout(timer);
  }, [onComplete]);

  return (
    <div className="healing-effect">
      <span className="healing-amount">+{amount}</span>
      <div className="healing-particles">
        {[...Array(5)].map((_, i) => (
          <div key={i} className="particle" style={{ animationDelay: `${i * 0.1}s` }} />
        ))}
      </div>
    </div>
  );
};
```

**CSS**:

```css
.healing-effect {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

.healing-amount {
  display: block;
  font-size: 24px;
  font-weight: bold;
  color: #4ade80;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  animation: healingFloat 1s ease-out;
}

.healing-particles {
  position: relative;
}

.particle {
  position: absolute;
  width: 8px;
  height: 8px;
  background-color: #86efac;
  border-radius: 50%;
  animation: particleRise 1s ease-out forwards;
}

@keyframes healingFloat {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  50% {
    opacity: 1;
    transform: translateY(-10px);
  }
  100% {
    opacity: 0;
    transform: translateY(-30px);
  }
}

@keyframes particleRise {
  0% {
    opacity: 1;
    transform: translateY(0) translateX(0);
  }
  100% {
    opacity: 0;
    transform: translateY(-50px) translateX(var(--x-offset, 0));
  }
}

.particle:nth-child(1) { --x-offset: -20px; }
.particle:nth-child(2) { --x-offset: -10px; }
.particle:nth-child(3) { --x-offset: 0; }
.particle:nth-child(4) { --x-offset: 10px; }
.particle:nth-child(5) { --x-offset: 20px; }
```

### ドレインエフェクトの実装

#### ドレインエフェクトコンポーネント

**`components/Battle/DrainEffect.tsx`**:

```typescript
import React from 'react';

interface DrainEffectProps {
  amount: number;
  sourcePosition: { x: number; y: number };
  targetPosition: { x: number; y: number };
  onComplete: () => void;
}

export const DrainEffect: React.FC<DrainEffectProps> = ({
  amount,
  sourcePosition,
  targetPosition,
  onComplete
}) => {
  React.useEffect(() => {
    const timer = setTimeout(onComplete, 1500);
    return () => clearTimeout(timer);
  }, [onComplete]);

  const angle = Math.atan2(
    targetPosition.y - sourcePosition.y,
    targetPosition.x - sourcePosition.x
  );

  return (
    <div
      className="drain-effect"
      style={{
        left: `${sourcePosition.x}px`,
        top: `${sourcePosition.y}px`
      }}
    >
      {[...Array(8)].map((_, i) => (
        <div
          key={i}
          className="drain-particle"
          style={{
            animationDelay: `${i * 0.1}s`,
            '--angle': `${angle}rad`,
            '--distance': `${Math.hypot(
              targetPosition.x - sourcePosition.x,
              targetPosition.y - sourcePosition.y
            )}px`
          } as React.CSSProperties}
        />
      ))}
      <span className="drain-amount">吸収: {amount}</span>
    </div>
  );
};
```

**CSS**:

```css
.drain-effect {
  position: absolute;
  pointer-events: none;
}

.drain-particle {
  position: absolute;
  width: 12px;
  height: 12px;
  background: radial-gradient(circle, #c084fc, #a855f7);
  border-radius: 50%;
  box-shadow: 0 0 10px #a855f7;
  animation: drainMove 1.5s ease-in forwards;
}

.drain-amount {
  position: absolute;
  font-size: 18px;
  font-weight: bold;
  color: #c084fc;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
  animation: drainTextFade 1.5s ease-out;
}

@keyframes drainMove {
  0% {
    opacity: 1;
    transform: translate(0, 0);
  }
  100% {
    opacity: 0;
    transform: translate(
      calc(cos(var(--angle)) * var(--distance)),
      calc(sin(var(--angle)) * var(--distance))
    );
  }
}

@keyframes drainTextFade {
  0%, 80% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}
```

### アニメーションの統合

#### BattleFieldコンポーネントでの使用例

```typescript
const BattleField: React.FC<BattleFieldProps> = ({ battleState }) => {
  const [currentEvent, setCurrentEvent] = useState<BattleEvent | null>(null);

  const handleTurnResult = (result: ProcessResult) => {
    const events = processTurnResult(result);
    playEvents(events);
  };

  const playEvents = async (events: BattleEvent[]) => {
    for (const event of events) {
      setCurrentEvent(event);
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    setCurrentEvent(null);
  };

  return (
    <div className="battle-field">
      <PokemonDisplay
        pokemon={battleState.player2.party[battleState.player2.activePokemonIndex]}
        isPlayer={false}
      />
      
      {currentEvent?.type === 'stat-change' && (
        <StatChangeIndicator statChanges={currentEvent.statChanges} />
      )}
      
      {currentEvent?.type === 'healing' && (
        <HealingEffect
          amount={currentEvent.amount}
          onComplete={() => setCurrentEvent(null)}
        />
      )}
      
      {currentEvent?.type === 'drain' && (
        <DrainEffect
          amount={currentEvent.amount}
          sourcePosition={/* calculate from pokemonId */}
          targetPosition={/* calculate from targetId */}
          onComplete={() => setCurrentEvent(null)}
        />
      )}
      
      <PokemonDisplay
        pokemon={battleState.player1.party[battleState.player1.activePokemonIndex]}
        isPlayer={true}
      />
    </div>
  );
};
```

### 注意事項

1. **アニメーション順序**: ダメージ → ステータス変化 → 回復/ドレイン の順で再生することを推奨
2. **パフォーマンス**: 大量のパーティクルはGPU負荷が高いため、適切に制限する
3. **アクセシビリティ**: アニメーション軽減モード（`prefers-reduced-motion`）への対応を検討

---

## トラブルシューティング

### よくある問題と解決策

#### 1. SignalR接続が確立できない

**原因**: CORS設定、認証トークン不正

**解決策**:
```csharp
// Program.cs
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.WithOrigins("http://localhost:3000")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});
```

#### 2. ターン結果が受信できない

**原因**: イベントハンドラの登録タイミング

**解決策**:
```typescript
// connection.start() の前にハンドラを登録
connection.on('ReceiveTurnResult', handleTurnResult);
await connection.start();
await connection.invoke('InitBattle', battleId);
```

#### 3. HP更新が反映されない

**原因**: 状態の不変性違反

**解決策**:
```typescript
// ❌ 間違い
state.battleState.player1.party[0].currentHp -= damage;

// ✅ 正しい
setBattleState({
  ...state.battleState,
  player1: {
    ...state.battleState.player1,
    party: state.battleState.player1.party.map((p, i) =>
      i === 0 ? { ...p, currentHp: p.currentHp - damage } : p
    )
  }
});
```

---

## 実装チェックリスト

### 必須機能

- [ ] 認証フロー（ログイン・JWT保存）
- [ ] バトル作成（対人・CPU）
- [ ] SignalR接続確立
- [ ] バトル初期化（InitBattle）
- [ ] 技選択UI
- [ ] アクション送信（SubmitAction）
- [ ] ターン結果受信（ReceiveTurnResult）
- [ ] HP表示・更新
- [ ] ダメージアニメーション
- [ ] バトルログ表示
- [ ] 勝敗判定・結果画面

### 追加機能

- [ ] ポケモン交代機能
- [ ] タイプ相性表示
- [ ] 状態異常表示（麻痺・火傷等）
- [ ] 能力ランク表示
- [ ] 急所エフェクト
- [ ] バトル履歴
- [ ] リプレイ機能
- [ ] サウンドエフェクト
- [ ] BGM
- [ ] チャット機能

---

## 参考リソース

### 公式ドキュメント

- [ASP.NET Core SignalR](https://learn.microsoft.com/ja-jp/aspnet/core/signalr/introduction)
- [SignalR JavaScript Client](https://learn.microsoft.com/ja-jp/aspnet/core/signalr/javascript-client)
- [Next.js Documentation](https://nextjs.org/docs)
- [React Documentation](https://react.dev/)
- [Zustand](https://github.com/pmndrs/zustand)

### コミュニティリソース

- [ポケモン対戦シミュレータ Pokemon Showdown](https://github.com/smogon/pokemon-showdown)
- [PokéAPI](https://pokeapi.co/)

---

## まとめ

このドキュメントでは、バックエンドのBattleServiceとSignalR Hubを活用して、フロントエンドでリアルタイムバトルを実装する手順を説明しました。

**重要なポイント**:

1. **SignalRによるリアルタイム通信**: 両プレイヤーのアクションを同期し、ターン結果を即座に配信
2. **状態管理の適切な設計**: BattleStateをフロントエンドで正確に管理し、UIに反映
3. **アニメーションとUX**: ダメージ、HP減少、タイプ相性などを視覚的に表現
4. **エラーハンドリング**: 接続切断、再接続、アクション失敗への対応

バックエンドはすでに完全に実装されているため、フロントエンドはこのドキュメントに従ってSignalRクライアントを実装し、UIコンポーネントを作成するだけで、完全なバトルシステムが動作します。

頑張ってください！🔥
