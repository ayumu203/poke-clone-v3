# フロントエンド実装予定

## 目次

1. [概要](#概要)
2. [バックエンドAPI仕様](#バックエンドapi仕様)
3. [認証フロー](#認証フロー)
4. [フロントエンド実装手順](#フロントエンド実装手順)
5. [環境構築](#環境構築)
6. [デプロイ手順](#デプロイ手順)

---

## 概要

本ドキュメントは、ポケモンクローンゲームのフロントエンド実装の完全なガイドです。バックエンドAPIとSignalRを活用し、リアルタイム対戦機能を実現します。

### システム構成

```
┌─────────────────┐         ┌──────────────────┐         ┌─────────────┐
│ React/Next.js   │  HTTP   │  ASP.NET Core    │  Redis  │   Redis     │
│  フロント       ├────────►│  WebAPI          ├────────►│   Cache     │
│                 │◄────────┤  + SignalR Hub   │         └─────────────┘
└─────────────────┘ SignalR └──────────────────┘
                              ↓
                         ┌──────────────────┐
                         │  SQL Server DB   │
                         └──────────────────┘
```

---

## バックエンドAPI仕様

### 1. 認証API

#### POST `/api/Auth/login/mock`

**用途**: 開発用モック認証（本番では無効化）

**リクエスト**:
```json
{
  "username": "testplayer1",
  "password": "testpassword"
}
```

**レスポンス**:
```json
{
  "message": "Logged in",
  "username": "testplayer1",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Auth/login/mock \
  -H "Content-Type: application/json" \
  -d '{"username": "testplayer1", "password": "testpassword"}'
```

**使用方法**:
1. JWTトークンを取得
2. トークンをローカルストレージまたはCookieに保存（レスポンスにはCookieも自動設定されます）
3. 以降のAPIリクエストで`Authorization: Bearer {token}`ヘッダーを付与

#### POST `/api/Auth/logout`

**用途**: ログアウト（Cookieからトークンを削除）

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Auth/logout \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### GET `/api/Auth/status`

**用途**: 現在の認証状態を確認

**レスポンス**:
```json
{
  "isAuthenticated": true,
  "userId": "user-uuid-1234",
  "name": "testplayer1",
  "message": "Authenticated"
}
```

**curlテスト例**:
```bash
# 認証なし
curl -X GET http://localhost:5278/api/Auth/status

# 認証あり
curl -X GET http://localhost:5278/api/Auth/status \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### 2. プレイヤーAPI

#### GET `/api/Player/me`

**用途**: 認証済みユーザーのプレイヤー情報を取得

**レスポンス例**:
```json
{
  "playerId": "user-uuid-1234",
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Player/me \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### POST `/api/Player/me`

**用途**: プレイヤー情報の作成または更新

**リクエスト**:
```json
{
  "name": "サトシ",
  "iconUrl": "https://example.com/icon.png"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Player/me \
  -H "Authorization: Bearer {YOUR_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"name": "サトシ", "iconUrl": "https://example.com/icon.png"}'
```

---

### 3. パーティAPI

#### GET `/api/Party`

**用途**: プレイヤーのパーティ一覧を取得

**レスポンス例**:
```json
[
  {
    "pokemonId": "poke001",
    "pokemonSpeciesId": 25,
    "level": 25,
    "exp": 0,
    "moves": [
      {
        "moveId": 1,
        "name": "でんきショック",
        "type": "Electric",
        "damageClass": "Special",
        "power": 40,
        "accuracy": 100,
        "pp": 30
      }
    ]
  }
]
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Party \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### DELETE `/api/Party/{pokemonId}`

**用途**: ポケモンを逃がす（パーティから削除）

**curlテスト例**:
```bash
curl -X DELETE http://localhost:5278/api/Party/{pokemonId} \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### 4. スターターAPI

#### GET `/api/Starter/options`

**用途**: スターターポケモンの選択肢を取得

**レスポンス例**:
```json
[
  {
    "pokemonSpeciesId": 390,
    "name": "ヒコザル",
    "frontImage": "/images/390_front.png",
    "backImage": "/images/390_back.png",
    "type1": "Fire",
    "type2": null,
    "baseHp": 44,
    "baseAttack": 58,
    "baseDefence": 44,
    "baseSpecialAttack": 58,
    "baseSpecialDefence": 44,
    "baseSpeed": 61,
    "moveList": []
  }
]
```

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Starter/options \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### POST `/api/Starter/select`

**用途**: スターターポケモンを選択

**リクエスト**:
```json
{
  "pokemonSpeciesId": 390
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Starter/select \
  -H "Authorization: Bearer {YOUR_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"pokemonSpeciesId": 390}'
```

---

### 5. バトルAPI

#### POST `/api/Battle/cpu`

**用途**: CPUバトルの作成

**レスポンス例**:
```json
{
  "battleId": "battle-uuid-1234",
  "player1": {
    "playerId": "user-uuid-1234",
    "player": {
      "playerId": "user-uuid-1234",
      "name": "サトシ",
      "iconUrl": "https://example.com/icon.png"
    },
    "activePokemonIndex": 0,
    "party": [
      {
        "pokemonId": "poke001",
        "pokemonSpeciesId": 25,
        "currentHp": 95,
        "maxHp": 95,
        "ailment": "None",
        "rank": {
          "attack": 0,
          "defence": 0,
          "specialAttack": 0,
          "specialDefence": 0,
          "speed": 0,
          "accuracy": 0,
          "evasion": 0
        }
      }
    ],
    "action": null
  },
  "player2": {
    "playerId": "cpu",
    "player": {
      "playerId": "cpu",
      "name": "CPU",
      "iconUrl": null
    },
    "activePokemonIndex": 0,
    "party": [
      {
        "pokemonId": "cpu-poke001",
        "pokemonSpeciesId": 19,
        "currentHp": 60,
        "maxHp": 60,
        "ailment": "None",
        "rank": {
          "attack": 0,
          "defence": 0,
          "specialAttack": 0,
          "specialDefence": 0,
          "speed": 0,
          "accuracy": 0,
          "evasion": 0
        }
      }
    ],
    "action": null
  },
  "turn": 0,
  "createdAt": "2025-12-05T01:00:00Z",
  "expireAt": "2025-12-05T02:00:00Z"
}
```

**curlテスト例**:
```bash
curl -X POST http://localhost:5278/api/Battle/cpu \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

#### GET `/api/Battle/{battleId}`

**用途**: 現在のバトル状態を取得

**curlテスト例**:
```bash
curl -X GET http://localhost:5278/api/Battle/{battleId} \
  -H "Authorization: Bearer {YOUR_TOKEN}"
```

---

### 6. SignalR Hub (BattleHub)

#### `JoinBattle(string battleId)`

**目的**: バトルルームへの接続

**フロントエンド実装**:
```typescript
// SignalR接続確立後に呼び出す
await connection.invoke("JoinBattle", battleId);
```

#### `SubmitAction(string battleId, PlayerAction action)`

**目的**: プレイヤーのアクションを送信

**PlayerAction構造**:
```typescript
interface PlayerAction {
  playerId: string;
  actionType: ActionType;  // 0: Attack, 1: Switch, 2: Catch
  value: number;           // moveIdまたはswitchPokemonIndex
}

enum ActionType {
  Attack = 0,
  Switch = 1,
  Catch = 2
}
```

**フロントエンド実装**:
```typescript
// 攻撃アクション
const attackAction = {
  playerId: "player1",
  actionType: 0, // Attack
  value: 1  // moveId
};

await connection.invoke("SubmitAction", battleId, attackAction);

// 交代アクション
const switchAction = {
  playerId: "player1",
  actionType: 1, // Switch
  value: 2  // pokemonIndex
};

await connection.invoke("SubmitAction", battleId, switchAction);
```

#### `ReceiveTurnResult` (クライアント受信)

**目的**: ターン処理結果の受信

**ProcessResult構造**:
```typescript
interface ProcessResult {
  actionResults: ActionResult[];
  isBattleEnd: boolean;
  winnerId: string;
  endResult?: EndResult;
}

interface ActionResult {
  actionPokemonId: string;
  actionType: number;
  moveResult?: MoveResult;
  switchResult?: SwitchResult;
  catchResult?: CatchResult;
  escapeResult?: EscapeResult;
}

interface MoveResult {
  moveId: number;
  targetId: string;
  isSuccess: boolean;
  failureReason: string;
  damage: number;
  hitContext?: {
    isCritical: boolean;
    typeEffectiveness: number;
  };
  sourceRankChange?: Rank;
  targetRankChange?: Rank;
  ailment?: string;
  sourceStatChanges?: StatChange[];
  targetStatChanges?: StatChange[];
  healing?: number;
  drain?: number;
}

interface EndResult {
  reason: string;  // "AllFainted", "Caught", "Escaped"
  winnerId?: string;
  evolutionInfo?: EvolutionInfo[];
}
```

**フロントエンド実装**:
```typescript
connection.on("ReceiveTurnResult", (result: ProcessResult) => {
  // ターン結果を処理
  result.actionResults.forEach(action => {
    if (action.moveResult) {
      // ダメージアニメーション表示
      displayDamage(action.moveResult.damage);
      
      // HP更新
      updatePokemonHp(action.moveResult.targetId, action.moveResult.damage);
      
      // エフェクト表示
      if (action.moveResult.hitContext?.isCritical) {
        showCriticalEffect();
      }
    }
  });
  
  // バトル終了判定
  if (result.isBattleEnd) {
    showBattleResult(result.endResult);
  }
});
```

---

## 認証フロー

### 開発環境での認証

開発環境では、モック認証を使用して迅速にテストできます。

#### モック認証フロー

```typescript
// pages/login.tsx
async function handleMockLogin() {
  const response = await fetch('http://localhost:5278/api/Auth/login/mock', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'devuser', password: 'devpass' })
  });
  
  const data = await response.json();
  localStorage.setItem('jwt_token', data.token);
  window.location.href = '/';
}
```

> [!WARNING]
> **モック認証は開発環境専用**
> 本番環境では、Google OAuth、Microsoft OAuth、またはEmail OTPを使用してください。

---

## フロントエンド実装手順

### Step 1: プロジェクトセットアップ

#### 必要なライブラリ

```bash
# Next.js（推奨）
npx create-next-app@latest poke-clone-frontend --typescript

# SignalR クライアント
npm install @microsoft/signalr

# 状態管理（Zustand推奨）
npm install zustand

# APIクライアント
npm install axios

# スタイリング
npm install tailwindcss @tailwindcss/forms

# Storybook のセットアップ
npx storybook@latest init
```

#### プロジェクト構造

```
Client/
├── src/
│   ├── components/
│   │   ├── Battle/
│   │   │   ├── BattleField.tsx
│   │   │   ├── BattleField.stories.tsx
│   │   │   ├── PokemonDisplay.tsx
│   │   │   ├── PokemonDisplay.stories.tsx
│   │   │   ├── HPBar.tsx
│   │   │   ├── HPBar.stories.tsx
│   │   │   ├── MoveSelector.tsx
│   │   │   ├── MoveSelector.stories.tsx
│   │   │   └── BattleLog.tsx
│   │   └── Auth/
│   │       ├── Login.tsx
│   │       └── Login.stories.tsx
│   ├── hooks/
│   │   ├── useBattle.ts
│   │   ├── useSignalR.ts
│   │   └── useAuth.ts
│   ├── services/
│   │   ├── api.ts
│   │   └── signalr.ts
│   ├── stores/
│   │   ├── battleStore.ts
│   │   └── authStore.ts
│   ├── types/
│   │   ├── battle.ts
│   │   ├── pokemon.ts
│   │   └── action.ts
│   └── utils/
│       ├── typeEffectiveness.ts
│       └── damageCalculator.ts
│
├── .storybook/
│   ├── main.js
│   └── preview.js
│
├── .env.development
├── .env.production
└── package.json
```

---

### Step 2: 型定義

**`types/battle.ts`**:

```typescript
export interface BattleState {
  battleId: string;
  player1: PlayerState;
  player2: PlayerState;
  turn: number;
  createdAt: string;
  expireAt?: string;
}

export interface PlayerState {
  playerId: string;
  player: Player;
  activePokemonIndex: number;
  party: PokemonState[];
  action?: PlayerAction;
}

export interface PokemonState {
  pokemonId: string;
  pokemonSpeciesId: number;
  currentHp: number;
  maxHp: number;
  ailment: Ailment;
  rank: Rank;
  isFainted?: boolean;
}

export interface Player {
  playerId: string;
  name: string;
  iconUrl?: string;
}

export interface Rank {
  attack: number;
  defence: number;
  specialAttack: number;
  specialDefence: number;
  speed: number;
  accuracy: number;
  evasion: number;
}

export type Ailment = 
  | 'None' 
  | 'Paralysis' 
  | 'Sleep' 
  | 'Freeze' 
  | 'Burn' 
  | 'Poison' 
  | 'DeadlyPoisoned';

export type PokemonStat = 
  | 'attack' 
  | 'defense' 
  | 'special-attack' 
  | 'special-defense' 
  | 'speed' 
  | 'accuracy' 
  | 'evasion';

export interface StatChange {
  stat: PokemonStat;
  change: number;  // -6 ~ +6 の範囲
}

export interface PlayerAction {
  playerId: string;
  actionType: ActionType;
  value: number;  // moveId or switchPokemonIndex
}

export enum ActionType {
  Attack = 0,
  Switch = 1,
  Catch = 2
}

export interface ProcessResult {
  actionResults: ActionResult[];
  isBattleEnd: boolean;
  winnerId: string;
  endResult?: EndResult;
}

export interface ActionResult {
  actionPokemonId: string;
  actionType: ActionType;
  moveResult?: MoveResult;
  switchResult?: SwitchResult;
  catchResult?: CatchResult;
  escapeResult?: EscapeResult;
}

export interface MoveResult {
  moveId: number;
  targetId: string;
  isSuccess: boolean;
  failureReason: string;
  damage: number;
  hitContext?: {
    isCritical: boolean;
    typeEffectiveness: number;
  };
  sourceRankChange?: Rank;
  targetRankChange?: Rank;
  ailment?: string;
  sourceStatChanges?: StatChange[];
  targetStatChanges?: StatChange[];
  healing?: number;
  drain?: number;
}

export interface SwitchResult {
  currentPokemonId: string;
  nextPokemonId: string;
}

export interface CatchResult {
  isSuccess: boolean;
  caughtPokemonId: string;
}

export interface EscapeResult {
  isSuccess: boolean;
}

export interface EndResult {
  reason: string;
  winnerId?: string;
  evolutionInfo?: EvolutionInfo[];
}

export interface EvolutionInfo {
  pokemonId: string;
  fromSpeciesId: number;
  toSpeciesId: number;
  fromSpeciesName: string;
  toSpeciesName: string;
}
```

---

### Step 3: SignalR接続管理

**`services/signalr.ts`**:

```typescript
import * as signalR from '@microsoft/signalr';

class SignalRService {
  private connection: signalR.HubConnection | null = null;
  
  async connect(token: string): Promise<signalR.HubConnection> {
    if (this.connection) {
      return this.connection;
    }
    
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5278';
    
    this.connection = new signalR.HubConnectionBuilder()
      .withUrl(`${apiUrl}/hubs/battle`, {
        accessTokenFactory: () => token,
        transport: signalR.HttpTransportType.WebSockets
      })
      .withAutomaticReconnect()
      .configureLogging(signalR.LogLevel.Information)
      .build();
    
    await this.connection.start();
    console.log('SignalR Connected');
    
    return this.connection;
  }
  
  async disconnect(): Promise<void> {
    if (this.connection) {
      await this.connection.stop();
      this.connection = null;
      console.log('SignalR Disconnected');
    }
  }
  
  getConnection(): signalR.HubConnection | null {
    return this.connection;
  }
}

export const signalRService = new SignalRService();
```

---

### Step 4: カスタムフック

**`hooks/useSignalR.ts`**:

```typescript
import { useEffect, useState } from 'react';
import { signalRService } from '@/services/signalr';
import { ProcessResult, PlayerAction, BattleState } from '@/types/battle';
import * as signalR from '@microsoft/signalr';

export const useSignalR = (
  battleId: string,
  token: string,
  onTurnResult: (result: ProcessResult) => void,
  onBattleStarted?: (state: BattleState) => void
) => {
  const [connection, setConnection] = useState<signalR.HubConnection | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const setupConnection = async () => {
      try {
        const conn = await signalRService.connect(token);
        
        // ターン結果受信ハンドラ
        conn.on('ReceiveTurnResult', (result: ProcessResult) => {
          console.log('Turn result received:', result);
          onTurnResult(result);
        });
        
        // バトル開始受信ハンドラ
        conn.on('BattleStarted', (state: BattleState) => {
          console.log('Battle started:', state);
          if (onBattleStarted) {
            onBattleStarted(state);
          }
        });
        
        // バトル終了受信ハンドラ
        conn.on('BattleEnded', (endResult: any) => {
          console.log('Battle ended:', endResult);
        });
        
        // エラー受信ハンドラ
        conn.on('Error', (errorMessage: string) => {
          console.error('SignalR Error:', errorMessage);
          setError(errorMessage);
        });
        
        // バトルルームに参加
        await conn.invoke('JoinBattle', battleId);
        
        setConnection(conn);
        setIsConnected(true);
      } catch (err) {
        console.error('SignalR connection error:', err);
        setError(err instanceof Error ? err.message : 'Unknown error');
      }
    };
    
    setupConnection();
    
    return () => {
      signalRService.disconnect();
    };
  }, [battleId, token]);
  
  const submitAction = async (action: PlayerAction) => {
    if (!connection) {
      throw new Error('SignalR not connected');
    }
    
    try {
      await connection.invoke('SubmitAction', battleId, action);
    } catch (err) {
      console.error('Failed to submit action:', err);
      throw err;
    }
  };
  
  return { connection, isConnected, error, submitAction };
};
```

---

### Step 5: バトル状態管理

**`stores/battleStore.ts`** (Zustand使用):

```typescript
import { create } from 'zustand';
import { BattleState, ProcessResult, PokemonState } from '@/types/battle';

interface BattleStore {
  battleState: BattleState | null;
  turnResult: ProcessResult | null;
  battleLog: string[];
  isWaitingForOpponent: boolean;
  
  setBattleState: (state: BattleState) => void;
  setTurnResult: (result: ProcessResult) => void;
  addLog: (message: string) => void;
  clearLog: () => void;
  updatePokemonHp: (pokemonId: string, damage: number) => void;
  setWaitingForOpponent: (waiting: boolean) => void;
  resetBattle: () => void;
}

export const useBattleStore = create<BattleStore>((set) => ({
  battleState: null,
  turnResult: null,
  battleLog: [],
  isWaitingForOpponent: false,
  
  setBattleState: (state) => set({ battleState: state }),
  
  setTurnResult: (result) => set({ turnResult: result }),
  
  addLog: (message) => set((state) => ({
    battleLog: [...state.battleLog, message]
  })),
  
  clearLog: () => set({ battleLog: [] }),
  
  updatePokemonHp: (pokemonId, damage) => set((state) => {
    if (!state.battleState) return state;
    
    const updateParty = (party: PokemonState[]) =>
      party.map(p => 
        p.pokemonId === pokemonId
          ? { ...p, currentHp: Math.max(0, p.currentHp - damage) }
          : p
      );
    
    return {
      battleState: {
        ...state.battleState,
        player1: {
          ...state.battleState.player1,
          party: updateParty(state.battleState.player1.party)
        },
        player2: {
          ...state.battleState.player2,
          party: updateParty(state.battleState.player2.party)
        }
      }
    };
  }),
  
  setWaitingForOpponent: (waiting) => set({ isWaitingForOpponent: waiting }),
  
  resetBattle: () => set({
    battleState: null,
    turnResult: null,
    battleLog: [],
    isWaitingForOpponent: false
  })
}));
```

---

## 環境構築

### 開発環境

#### 1. 環境変数設定

**`.env.development`**:
```bash
NEXT_PUBLIC_API_URL=http://localhost:5278
NEXT_PUBLIC_SIGNALR_URL=http://localhost:5278/hubs/battle
NEXT_PUBLIC_ENVIRONMENT=development
```

#### 2. Docker環境の起動

```bash
# プロジェクトルートで実行
cd Server
docker-compose up -d

# データベース初期化
dotnet ef database update --project src/Server.Infrastructure --startup-project src/Server.WebAPI

# シードデータ投入
dotnet run --project scripts/Program.cs
```

#### 3. バックエンド起動

```bash
cd Server/src/Server.WebAPI
dotnet run
```

#### 4. フロントエンド起動

```bash
cd Client
npm install
npm run dev
```

#### 5. Storybook起動（オプション）

```bash
cd Client
npm run storybook
```

---

### 本番環境（Azureデプロイ）

#### 1. Azureリソース作成

```bash
# リソースグループ作成
az group create \
  --name poke-clone-rg \
  --location japaneast

# App Service Plan作成
az appservice plan create \
  --name poke-clone-plan \
  --resource-group poke-clone-rg \
  --sku B1 \
  --is-linux

# Web App作成
az webapp create \
  --name poke-clone-api \
  --resource-group poke-clone-rg \
  --plan poke-clone-plan \
  --runtime "DOTNETCORE:8.0"

# Azure SQL Database作成
az sql server create \
  --name poke-clone-db-server \
  --resource-group poke-clone-rg \
  --location japaneast \
  --admin-user sqladmin \
  --admin-password YourPassword123!

az sql db create \
  --name pokedb \
  --resource-group poke-clone-rg \
  --server poke-clone-db-server \
  --service-objective S0

# Azure Cache for Redis作成
az redis create \
  --name poke-clone-redis \
  --resource-group poke-clone-rg \
  --location japaneast \
  --sku Basic \
  --vm-size c0

# Azure SignalR Service作成
az signalr create \
  --name poke-clone-signalr \
  --resource-group poke-clone-rg \
  --location japaneast \
  --sku Standard_S1 \
  --service-mode Default

# Key Vault作成
az keyvault create \
  --name poke-clone-keyvault \
  --resource-group poke-clone-rg \
  --location japaneast
```

#### 2. シークレット登録

```bash
# JWTシークレットキー
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name Jwt--Key \
  --value "your-super-secure-jwt-secret-key-minimum-32-characters"

# データベース接続文字列
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name ConnectionStrings--DefaultConnection \
  --value "Server=tcp:poke-clone-db-server.database.windows.net,1433;Initial Catalog=pokedb;Persist Security Info=False;User ID=sqladmin;Password=YourPassword123!;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"

# Redis接続文字列
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name ConnectionStrings--Redis \
  --value "poke-clone-redis.redis.cache.windows.net:6380,password=xxxxxxxxx,ssl=True,abortConnect=False"

# Azure SignalR接続文字列
az keyvault secret set \
  --vault-name poke-clone-keyvault \
  --name Azure--SignalR--ConnectionString \
  --value "Endpoint=https://poke-clone-signalr.service.signalr.net;AccessKey=xxxxxxxxx;Version=1.0;"
```

#### 3. App Serviceマネージドアイデンティティ設定

```bash
# マネージドアイデンティティを有効化
az webapp identity assign \
  --name poke-clone-api \
  --resource-group poke-clone-rg

# Key Vaultアクセスポリシーを設定
az keyvault set-policy \
  --name poke-clone-keyvault \
  --object-id {PRINCIPAL_ID} \
  --secret-permissions get list
```

#### 4. 環境変数設定

```bash
az webapp config appsettings set \
  --name poke-clone-api \
  --resource-group poke-clone-rg \
  --settings \
    ASPNETCORE_ENVIRONMENT=Production \
    KeyVault__VaultUri=https://poke-clone-keyvault.vault.azure.net/
```

---

## デプロイ手順

### GitHub Actionsでのデプロイ

**`.github/workflows/azure-deploy.yml`**:

```yaml
name: Deploy to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: poke-clone-api
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore Server/PokeClone.sln
    
    - name: Build
      run: dotnet build Server/PokeClone.sln --configuration Release --no-restore
    
    - name: Publish
      run: dotnet publish Server/src/Server.WebAPI/Server.WebAPI.csproj --configuration Release --no-build --output ./publish
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ./publish
```

### Vercelへのフロントエンドデプロイ

**`vercel.json`**:

```json
{
  "buildCommand": "npm run build",
  "outputDirectory": ".next",
  "framework": "nextjs",
  "env": {
    "NEXT_PUBLIC_API_URL": "https://poke-clone-api.azurewebsites.net",
    "NEXT_PUBLIC_SIGNALR_URL": "https://poke-clone-api.azurewebsites.net/hubs/battle",
    "NEXT_PUBLIC_ENVIRONMENT": "production"
  }
}
```

---

## セキュリティチェックリスト

### 開発環境

- [ ] User Secretsを使用してシークレットを管理
- [ ] `appsettings.Development.json`に機密情報を含めない
- [ ] Gitに`.env`ファイルをコミットしない
- [ ] CORS設定をlocalhostに限定

### 本番環境

- [ ] Azure Key Vaultですべてのシークレットを管理
- [ ] マネージドIDを使用してKey Vaultにアクセス
- [ ] HTTPS必須を有効化
- [ ] JWT SecretKeyは32文字以上のランダム文字列
- [ ] CORS設定を本番ドメインのみに限定
- [ ] Redisにパスワードを設定
- [ ] SQL DatabaseでAzure AD認証を有効化
- [ ] App ServiceでHTTPS Only設定を有効化
- [ ] 定期的にシークレットをローテーション

---

## トラブルシューティング

### SignalR接続エラー

**症状**: `Failed to start the connection: Error: WebSocket failed to connect.`

**原因**:
- バックエンドが起動していない
- CORS設定が正しくない
- JWTトークンが無効

**解決方法**:
1. バックエンドが起動していることを確認
2. `appsettings.Development.json`のCORS設定を確認
3. ブラウザのコンソールでJWTトークンを確認

### 認証エラー

**症状**: `401 Unauthorized`

**原因**:
- JWTトークンが期限切れ
- トークンがリクエストヘッダーに含まれていない

**解決方法**:
1. ローカルストレージのトークンを確認
2. `Authorization: Bearer {token}`ヘッダーが正しく設定されているか確認
3. トークンをリフレッシュ

### データベース接続エラー

**症状**: `SqlException: A network-related or instance-specific error occurred`

**原因**:
- Docker Composeが起動していない
- 接続文字列が間違っている

**解決方法**:
1. `docker-compose ps`でコンテナの状態を確認
2. `docker-compose up -d`で再起動
3. 接続文字列を確認

---

## 参考資料

### ドキュメント

- [要件定義.md](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/要件定義.md)
- [クラス図.drawio](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/UML/クラス図.drawio)
- [シーケンス図.drawio](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/UML/シーケンス図.drawio)
- [アーキテクチャ構成.drawio](file:///mnt/c/Users/cs23017/Shizuoka%20University/ドキュメント/dev/01_poke_clone-v3/Docs/UML/アーキテクチャ構成.drawio)

### 外部リンク

- [ASP.NET Core SignalR](https://learn.microsoft.com/ja-jp/aspnet/core/signalr/introduction)
- [Next.js Documentation](https://nextjs.org/docs)
- [Zustand Documentation](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [Microsoft SignalR Client for JavaScript](https://www.npmjs.com/package/@microsoft/signalr)
- [Azure App Service Documentation](https://learn.microsoft.com/ja-jp/azure/app-service/)
